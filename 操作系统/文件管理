# 文件

前言

open一个普通文件发生了什么事？

open一个设备文件发生了什么事？

## 内存

内存如何使用的？将程序放到内存中，让程序执行起来，内存就用起来了

重定位：修改程序中的地址【相对地址】在物理内存中的位置，在内存中找一块空闲空间，将程序放到这里

问题 什么时候重定位？

编译时，放在固定位置

载入时，程序不可再动

最合适的时机，运行时重定位，根据段基址放到程序中合适位置。段基址存放在PCB中

#### 内存分段

全部过程：在内存中找到一块空闲内存，将内存的基地址取出来放到PCB中，将程序放到找到的这块内存中，PCB中的基地址就变成了基址寄存器，每一次的取指执行，进行地址翻译就找到了这段程序实际使用的物理地址。

实际一段程序是分治处理，分成若干部分，每个段有各自的特点，比如主程序，变量集，函数库，动态数据，栈等，因此将每个段分别放入内存。实际寻址时，是根据【段号+偏移量】实现的。这些内容存放到LDT【Local Descriptor Table，局部描述符表】中，查找时候利用LDTR。每个任务的LDT被存放在自己的PCB中。

总结：

1. 将程序分段（编译时操作系统完成的）
2. 在内存中找一段空闲分区（一些算法）
3. 将程序读入到空闲分区做好映射表，初始化LDT、PCB

#### 内存分区

如何在内存中找到一块空闲分区？

#### 内存分页

内存访问使用分段机制【段基址 ：段偏移地址】方式，使用段描述符对内存加以管理，但如果应用程序过多，或者内存碎片过多，当新的请求来临时在内存中找不到合适大小的区域，如何解决？

实质：从连续到离散，给内存打散

将地址分为大小固定的页，按页为单位进行映射，每一页是4K，连续的线性地址可以映射到不连续的物理内存。

与分段的段表非常类似

```assembly
mov [0x2240],%eax
```

对于4G的内存，一页的大小是4K，将0x2240右移12位，等于2，在页表中找到页号为2的项，得到对应的页框，在内存中将找到页框对应的内存

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220624200152927.png" alt="image-20220624200152927" style="zoom: 80%;" />

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220624200217834.png" alt="image-20220624200217834" style="zoom:67%;" />

逻辑地址是 0x02 0x240

物理地址是 3 	  240

问题引入：为了提高内存空间利用率，页应该小一些，但是页小了页表就大了……如何解决这一问题？

页表中的页号要求必须连续，因为不连续查找起来耗时太多，因此提出了一种解决方案，多级页表。像目录一样的页表，一章一节的查找

对于32位的地址空间，查找一段内存，单级页表需要查找4M个页表项，现在只需要查找2K个页表项

<img src="https://img-blog.csdn.net/20180927174919664?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjUzMTQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />

页目录号有1024个，页号有1024个，每个页的大小是4K。

假设，需要访问12M的内存，多级页表仅需要访问16K个页表项即可。先查找章，无关章不需要访问，再查找节。节省了大量的内存消耗。

#### 段页结合的实际内存管理

程序需要分段【段面向用户的】，物理内存需要分页【页是面向物理内存的】

在虚拟内存中割出一段空间给程序，再将虚拟内存中的段映射到物理内存的页上，解决

首先根据段表找到在虚拟内存中的基址，再把虚拟地址计算映射到页表中，得到真正的物理地址

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220625095035658.png" alt="image-20220625095035658" style="zoom: 67%;" />

具体如何实现？

内存管理的核心就是内存分配，从程序放入内存，使用内存开始

分配段，建段表；分配页，建页表。虚拟内存中只记录起始地址与长度，不是真正的存放。再将这个段与物理内存的一页一页的关联起来，真正的存放到物理内存上。使用重定位具体使用内存

进程带动内存使用的图谱

例子：从进程fork中的内存分配开始

| 页目录号 | 页号 | 大小 |
| -------- | ---- | ---- |
| 10b      | 10b  | 12b  |

```c
fork()->sys_fork()->copy_process();
copy_process() 
{
	copy_mem();
}
int copy_mem(int nr, task_struct *p)
{
    unsigned long new_data_base;
    new_data_nase = nr*0x4000000; //64M * nr, 给进程分配虚拟内存【虚拟内存分割】
    //分配段表，p = PCB
    set_base(p->ldt[1], new_data_base); //代码段
    set_base(p->ldt[2], new_data_base); //数据段
    
    unsigned long old_data_base;
	old_data_base = get_base(currnet->ldt[2]); //将当前进程的虚拟内存地址赋给old_data_base
	copy_page_tables(old_data_base, new_data_base, data_limit);

}
int copy_page_tables(unsigned long from, unsigned long to , long size)
{
	from_dir = (unsigned long *) ((from>>20) & 0xffc);//指向父进程的页目录项
    //【(from >> 22)*4 = (from>>20) & 0xffc】
	to_dir = (unsigned long * )((to>>20) & 0xffc);//指向子进程的页目录项
	size = (unsigned long)(size + 0x3fffff) >> 22;//页目录项数
 	//拷贝
	for (; size-->0; from_dir++, to_dir++)
	{
		from_page_table=(0xfffff000 & *from_dir);
		to_page_table = get_free_page();
		*to_dir = ((unsigned long) to_page_table) | 7;
	}
}
```

**总结**：

1. 在虚拟内存上分配段；如何分配呢？首先肯定是得找到空闲的段，如何找？使用内存分区方法。
2. 然后将用户程序映射到虚拟内存，假装把用户程序放在虚拟内存中。也就是建立段表。当多进程图像进行是LDT跟着进程一起切换。
3. 物理内存找一个空闲页，分配页。
4. 建立页表。也就是页号（逻辑页）与页框号（物理页）的对应关系。子进程与父进程共用同一套页目录表，指向同一物理内存，但是不会混乱。
5. 重定位使用内存，将mov 300重定位为物理内存的0x007300。

#### 内存换入swap in

逻辑地址CS:IP，首先根据CS在段表中找到对应的基址，加上偏移得到虚拟地址，在根据页表找到对应页框号，加上偏移得到物理地址。当如果在页表中找不到页号对应的页框号的时候，怎么办？

从磁盘将这一页换入。

MMU，Memory Management Unit，内存管理单元，负责虚拟地址到物理地址的映射，并提供硬件机制的内存条件检查。

换入采用中断的形式，如果load[addr]的时候，发现addr在页表里面没有对应映射，那么就将中断向量寄存器的某一位置为一，说明有中断产生。然后在中断服务函数里面将addr导入到物理内存中。然后再次执行load[addr]这条语句。当然查表的操作是MMU做的。

#### 内存换出swap out

内存映射时，发现没有对应映射，就会采取内存换入的操作，但是不能总是获得新的页，内存是有限的，当页框满了，无法获取新的页，如何解决这一问题？

需要淘汰一页，换出到磁盘，那么如何选择那一页淘汰？

**OPT，最佳置换算法**

每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。实际上，进程只有在执行过程中才会知道接下来会访问哪个页面，操作系统无法提前预判页面访问序列。

**FIFO，先进先出算法**

将调入内存的页面根据调入的先后顺序排成一个序列，每次选择淘汰的页面是最早进入内存的页面，性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。

**LRU，Least Recently Used** 

近期最少使用算法，用一个页码栈记录页框使用情况，每次地址访问都需要修改栈，实现起来代价很大。LRU性能较好，但需要寄存器和栈的硬件支持。

**Clock算法，时钟置换算法，也叫而从机会算法**

为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一 个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第N轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220625172144571.png" alt="image-20220625172144571" style="zoom: 67%;" />

**总结——swap分区管理：**

1. <u>页面换入换出==>实现虚拟内存==>为了实现段页机制==>为了实现程序执行起来==>最终是进程</u>
2. <u>一个进程分为很多段，形成很多页面，但是页框可能不足够，此时产生缺页中断，进行页面调入调出</u>
3. <u>当访问内存时，页面不存在，产生缺少中断，然后从磁盘中调入到页面到物理内存，此时可能页框满，需要根据clock算法将页面写入到磁盘，然后再将调入的页面写入到内存中</u>

## IO设备

一些基础：

硬盘的最小存储单位是扇区Sector，每个扇区存储512个字节，相当于0.5KB

操作系统读取硬盘，一次性读取一个块Block，是文件存储的最小单位，每个块的大小是4KB

文件的元信息存放在inode索引节点中，inode中存放文件字节数、拥有者、读写权限、block的位置等等

inode节点：



**每个进程在PCB中保存着一份文件描述符表，fd就是这个表的索引，每个表项都有一个指向已打开文件的指针，文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。**

### 终端设备管理

外设如何工作？  	操作系统给响应外设对应的寄存器写入内容，控制器根据寄存器的内容实际操控硬件，当外设工作完后，向CPU发送中断，CPU进行中断的处理

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220627110857794.png" alt="image-20220627110857794" style="zoom: 67%;" />

IO读写整体三步原理

1. cpu取址执行通过out指令向外设发送命令
2. 将命令通过文件形成统一文件视图【固定的文件接口open、read、write、close等】进行解释
3. 外设执行完命令后返回给cpu进行中断处理（显示器：显示图像；键盘：读数据到内存）

**打开外设文件open，不论什么设备都是open、read、write、close。区别在于文件名，不同的文件名对应不同的设备【磁盘、键盘、显示器等等】，根据设备文件找到控制器地址、内容格式等等。**

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220626111638784.png" alt="image-20220626111638784" style="zoom: 67%;" />

printf【操作外设的程序】的整个过程：

创建缓冲buf将输出写入，再调用write(1, buf, ...)

```c
int sys_write(unsigned int fd,char * buf,int count) //fd = 1
{
	struct file * file;
    file = current->filp[fd]; //current当前进程 1对应的文件赋给file
	struct m_inode * inode;
	inode = file->f_inode; //将file文件中的信息取出来，放到inode
    //……
}
static crw_ptr crw_table[] = {..., rw_ttyx, ...}; //存放设备处理函数
int rw_ttyx(int rw, ...)
{
    tty_write(..., buf, ...);
}
int tty_write(..., char * buf, ...) //实现输出的核心函数
{
    tty->write(q); //放入队列中【缓冲】
}
void con_write() //写到屏幕上
{
    mov pos,c //pos显卡寄存器
}
```

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220627110523383.png" alt="image-20220627110523383" style="zoom:67%;" />

### 磁盘管理

#### 生磁盘

多个进程使用磁盘：产生请求，将请求放入请求队列中，在磁盘中断上取出请求得到盘块号，换算成C【盘/柱面】、H【磁头】、S【扇区】，再通过OUT发送给响应的磁盘控制器

磁盘IO过程

1. 将磁头移动到指定的磁道
2. 将磁头旋转到磁道中的指定扇区
3. 对指定扇区进行磁盘数据IO读写

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220627111518547.png" alt="image-20220627111518547" style="zoom: 67%;" />

1. 如何得到盘块号？从文件中获取。根据盘块号得到扇区号sector
2. 利用扇区号做一个内存请求，得到一块缓冲区，利用电梯算法将请求放入请求队列中
3. 放入请求后，这个进程就可以睡眠了
4. 磁盘中断处理请求，算出CHS，再通过OUT发送给响应的磁盘控制器
5. 工作结束后，再次进行中断处理，将这个请求结束，唤醒进程，通知进程在内存缓冲区已经有需要读写的内容

#### 从生磁盘到文件，如何从文件得到盘块号？

建立一种字符流到盘块集合的映射关系

常见映射关系：顺序结构、链式结构、索引

实际使用的一般是多级索引

fprintf 就是操作磁盘的程序；

根据文件名/路径名找到inode，根据inode找到盘块号，根据盘块号放入电梯队列……

若驱动其他外设，同样也是根据文件名打开PCB，根据PCB找到文件表，根据文件表找到inode，根据inode存放的函数，最后输出……

#### 文件系统

文件控制块FCB【File Control Block】，用来存放控制文件需要的各种信息的数据结构，实现按名存取。一个FCB就是一个目录项，当创建一个新文件时，系统将分配一个FCB并存放在文件目录中，成为目录项，目录项中包含了文件名+索引节点（inode）指针。

文件描述符fd，open打开文件得到的是一个文件描述符【就是索引号】，存放在task_struct【进程控制块】中，进程控制块与file结构体相连，实现对文件的操作。

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220627191755825.png" alt="image-20220627191755825" style="zoom: 67%;" />

**文件对磁盘的使用完整过程**

用户在应用层调用open函数打开文件设备时，会根据路径名找到改设备文件对应的目录项，再从目录项中找到索引节点指向inode结构体，通过inode中的信息知道接下来要操作的设备类型【键盘显示器等字符设备、磁盘等块设备】，同时分配一个file结构体。

根据inode结构体中记录的设备号，找到对应的驱动函数【read、write等】。

任务完成后，操作系统会返回一个文件描述符fd，通过fd可以将进程控制块与file结构体呼应，上层程序可以通过fd找到对应的file，实现对文件的操作。

若通过fd对打开的设备文件进行write函数调用，通过系统调用进入内核，执行对应的sys_write底层函数，根据传入的文件描述符fd作为下标，在进程控制块中找到对应的file结构体，里面存放了目录项的指针，以及文件操作函数的指针。根据函数指针找到对应的操作函数，以及目录项指向的该设备文件的inode结构体。

inode结构体中存放了设备文件的设备号，设备类型等信息。当inode表示一般文件的时候，里面存放文件字符流到盘块号的映射关系，根据inode找到盘块号，构造请求放入电梯队列，根据盘块号计算出磁盘的CHS，最终操作物理地址，从磁盘读写数据。

inode节点：

- 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息；
- 特殊文件(比如乱码文件名)可以通过inode的方式删除；
- 每个inode结点的大小，一般是128字节，或256字节。










