# 栈与队列

deque：push_front,  pop_front,  front,  push_back,  pop_back,  back,  insert,  empty,  size, sort

stack: top,  pop,  empty,  size,  push

queue:  front,  back,  push,  pop,  empty,  size

stack、queue是容器吗？不是，属于容器适配器，底层由deque或list某些功能实现的。

stack、queue提供迭代器来遍历空间吗？不提供

提供获取内部元素的接口吗？不提供

栈里面的元素在内存中是连续分布的吗？（数据结构类型，不属于线性结构）

1. 栈是容器适配器，底层使用不同的容器，导致栈内数据在内存中分布由底层容器决定
2. 缺省情况下，默认底层容器是deque，deque在内存中的数据分布是分段连续的。

#### 栈经典题目

1. 栈在系统中的应用 力扣71
2. 括号匹配问题 

三种情况 

1. 第一种情况，字符串里左方向的括号多余了 ，所以不匹配。
2. 第二种情况，括号没有多余，但是 括号的类型没有匹配上。
3. 第三种情况，字符串里右方向的括号多余了，所以不匹配。

比较栈顶元素是否与当前元素相等

3. 字符串去重问题

思路与括号问题相似，将字符串按照顺序压入栈中，相同的话就弹出，剩下的都是不相邻的元素

4. 逆波兰表达式

相邻符号前的两个数字取出计算，再将结果压入栈，与字符串消除问题雷同

#### 滑动窗口最大值问题

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        //单调队列，存放数组下标
        vector<int> result;
        deque<int> q;
        int n = 0;
        for (int i = 0; i < nums.size(); i++) {
            n++;
            while (!q.empty() && nums[q.back()] <= nums[i]) q.pop_back();
            q.push_back(i);
            while (!q.empty() && q.front() <= i - k) q.pop_front();
            if (n == k) {
                result.push_back(nums[q.front()]);
                n--;
            }
        }
        return result;
    }
};
```

#### 求前K个高频元素

法一，哈希表

法二，优先级队列

**优先级队列定义**

```c++
priority_queue<Type, Container, Functional>;
```

接口 top()、push()、pop()

内部元素是自动依据元素的权值进行排列

Type是要存放的数据类型

Container是实现底层堆的容器，必须是数组实现的容器，如vector、deque

Functional是比较方式/比较函数/优先级

```c++
priority_queue<Type>;
```

缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树），默认的比较方式是less<Type>。

```C++
//小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//大顶堆
priority_queue <int,vector<int>,less<int> >q;
//默认大顶堆
priority_queue<int> a;
//pair
priority_queue<pair<int, int> > a;
pair<int, int> b(1, 2);
pair<int, int> c(1, 3);
pair<int, int> d(2, 5);
a.push(d);
a.push(c);
a.push(b);
while (!a.empty()) 
{
   cout << a.top().first << ' ' << a.top().second << '\n';
   a.pop();
}
//输出结果为：
2 5
1 3
1 2
```

有两种自定义方式

1. 重载“<“运算符

```c++
struct myComparison {
    bool operator< (pair<int,int>&p1, pai<int,int>&p2) {
        return p1.second > p2.second;  //小项堆
    }
};
```

2. 仿函数

```c++
struct myComparison{
    bool operator()(pair<int,int>&p1,pair<int,int>&p2){
        return p1.second>p2.second;//小顶堆是大于号
    }
};
```

解体三部曲

1. 创建比较方式
2. 创建优先队列
3. 遍历map
