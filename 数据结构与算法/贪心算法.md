# 贪心算法

贪心算法，字面意思就是说，找出局部最优能够推出全局最优。多数用于数组、字符串等。

**2022/3/27**

#### 力扣55题 跳跃游戏

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

思路：设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为`x + nums[x]`，这个值大于等于 y，那么位置 y也可以到达。

依次遍历数组中的每一个位置，保存当前能够跳跃的最大位置，在此范围内依次计算每个位置下能够跳到的最大位置，若大于等于y，则返回true。

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int curMaxJump = 0; //当前可跳的最大范围
        for (int i = 0; i < nums.size(); i++) {
            if (curMaxJump >= nums.size() - 1) return true;
            curMaxJump = max(curMaxJump, i + nums[i]);
            if (i == curMaxJump) return false;  //跳到最大范围且当前可跳步数为0
        }
        return false;
    }
};
```

#### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

在上一题基础上，寻找跳到末尾的最小步数方案。

思路：每次找到可达位置的最远距离。

输入：`[2,3,1,2,4,2,3]`

从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。

从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) {
            return 0;
        }
        int res = 1;           //初始化为一步
        int curlen = nums[0];  //当前最远位置
        int nextlen = nums[0]; //吓一跳最远位置
        for (int i = 1; i < nums.size(); i++) {
            if (curlen >= nums.size() - 1) {
                return res;
            }
            nextlen = max(nextlen, i + nums[i]);
            if (i == curlen) { //跳到当前位置，更新吓一跳位置
                res++;
                curlen = nextlen;
            }
        }
        return res;
    }
};
```

#### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

```c++
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        int res = 0;
        sort(nums.begin(), nums.end());
        int i = 0;
        // while (i < nums.size() && nums[i] < 0 && k--) {
        //     nums[i] = -nums[i];
        //     i++;
        // }
        // 错误写法，k--先判断k后再减一，当k = 0时，不满足条件跳出循环，此时k = k - 1 = -1
        // 再往下运行时，k<0且k存在，会一直死循环
        while (i < nums.size() && nums[i] < 0 && k) {
            nums[i] = -nums[i];
            i++;
            k--;
        }
        sort(nums.begin(), nums.end());
        //数组全部是正数或者 K 已经用完
        while (k) {
            nums[0] = -nums[0];
            k--;
        }
        for (auto & x : nums) {
            res += x;
        }
        return res;
    }
};
```

#### [134. 加油站](https://leetcode.cn/problems/gas-station/)

核心思想就是：找到能跑完一圈的初始地点

前提是能够跑完一圈，首先判断总的油量、总的消耗油量

计算每一次的当前剩余油量，从0开始，若当前小于0，更新初始位置【因为总的油量够用】，所以一定存在初始

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        //先判断总油量是否满足耗油量
        int sum1 = 0;
        for (auto & x : gas) {
            sum1 += x;
        }
        int sum2 = 0;
        for (auto & x : cost) {
            sum2 += x;
        }
        //小于返回 -1
        if (sum1 < sum2) {
            return -1;
        }
        //大于等于0，一定存在起始点，找到初始值大于等于0的点位即可
        int cursum = 0;
        int res = 0;
        for (int i = 0; i < gas.size(); i++) {
            cursum += gas[i] - cost[i];
            if (cursum < 0) {
                cursum = 0;
                res = i + 1;
            }
        }
        return res;
    }
};
```

**2022/3/28**

#### [135. 分发糖果！！！](https://leetcode.cn/problems/candy/)

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

有个隐藏的条件，我自己给想复杂了，**当相邻孩子分数相同时，他们的糖果也可以相同**，我开始理解成相邻孩子的糖果数必须不同

思路：三种情况

第一种：递增，右边比左边大，将右边的值加一

第二种：递减，利用while确定递减区间`[i, index]`，从小到大记录。最后判断`v[i]与v[i - 1]`

第三种：相等，设为1

```C++
vector<int> ratings{ 1, 6, 10, 8, 7, 3, 2};
输出：18
```

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int res = 0;
        int n = ratings.size();
        vector<int> v(n, 0);
        v[0] = 1;
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                v[i] = v[i - 1] + 1;
            } else if (ratings[i] < ratings[i - 1]) {
                int index = i;
                while (index < n && ratings[index] < ratings[index - 1]) {
                    index++;
                }
                index--;
                //[i, index]
                v[index] = 1;
                for (int j = index - 1; j >= i; j--) {
                    v[j] = v[j + 1] + 1;
                }
                if (v[i] >= v[i - 1]) {
                    v[i - 1] = v[i] + 1;
                }
                i = index;
            } else {
                v[i] = 1;
            }
        }
        for (auto & x : v) {
            res += x;
        }
        return res;
    }
};
```

#### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

要求：身高从小到大排序，第二个属性是前边有几个大于等于自己身高的个数。

思路：先自定义排序方式。再根据第二个参数，从前往后数相应比自己高的，找到自己位置（当找到后，判断当前是否比自己矮）

输入：`[[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]`

输出：`[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]`

`[[4,0],[5,0],[6,0],[2,2],[3,2],[1,4]]`

`[[4,0],[5,0],[2,2],[6,0],[3,2],[1,4]]`

`[[4,0],[5,0],[2,2],[3,2],[6,0],[1,4]]`

```c++
class Solution {
public:
    static bool mysort(vector<int>& p1, vector<int>& p2) {
        if (p1[1] == p2[1]) {
            return p1[0] < p2[0];
        }
        return p1[1] < p2[1];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        //按照第二个参数重新排序
        sort(people.begin(), people.end(), mysort);
        for (int i = 0; i < people.size(); i++) {
            if (people[i][1] == 0) {
                continue;
            }
            int nums = 0;
            int j = 0;
            //遍历[0, i]区间，找到合适位置
            for (; j < i; j++) {
                if (people[j][0] >= people[i][0]) {
                    nums++;
                    //找到比自己身高高的人的个数，跳过比自己爱德人
                    if (nums == people[i][1]) {
                        while (j + 1 < i && people[j + 1][0] < people[i][0]) {
                            j++;
                        }
                        break;
                    }
                }
            }
            //两两交换到合适位置
            for (int k = i; k - 1 > j; k--) {
                swap(people[k], people[k - 1]);
            }
        }
        return people;
    }
};
```

#### [435. 无重叠区间！！！](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

**思路：做题时，想多想想反向思维。比如此题要求删除的最小区间数目，可以求出最大的非重叠区间数目，做差。**

**边界相交不算重叠。当前区间右边界小于等于下一区间左边界就是不重叠。**

**排序选择：找到不重叠的区间个数，从左向右遍历时，希望有边界小一点，这样才会尽可能地不重叠，所以选择按照有边界升序排序（右边界相同，情况下按照原顺序）**

```c++
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
```

```c++
class Solution {
public:
    static bool mysort(const vector<int>& intervals1, const vector<int>& intervals2) {
        if (intervals1[0] == intervals2[0]) return intervals1[1] < intervals2[1];
        else return intervals1[0] < intervals2[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), mysort);
        int count = 1;
        int right = intervals[0][1];
        for (int i = 1; i < intervals.size(); i++) {
            if (right <= intervals[i][0]) {
                right = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```

**2022/3/29**

#### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表

首先遍历一遍字符串，找到每个字母的最远出现位置，记录下来。

接着再重新遍历字符串，记录当前字符串中字符出现的最远位置，当遍历下标等于最远位置时，说明找到一个之后没有出现字符的字符串。

```c++
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
```

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> res;
        unordered_map<char, int> umap; //记录每个字母的最远坐标
        int index = 0;
        for (auto & c : s) {
            umap[c] = index++;
        }
        int left = 0;
        int curmaxindex = umap[s[0]];  //当前字符串片段的最远右边界
        for (int i = 0; i < s.size(); i++) {
            curmaxindex = max(curmaxindex, umap[s[i]]);
            if (i == curmaxindex) {
                //达到最远右边界，加入res数组
                res.push_back(i - left + 1);
                left = i + 1;
            }
        }
        return res;
    }
};
```

#### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

思路：此题坑比较多

**排序选择：根据左边界排序，找到所有重叠边界。左边界相同时，按右边界**

每一次的合并：左边界不变，右边界取最大

```c++
输入：[[2,3],[4,5],[6,7],[8,9],[1,10]]
输出：[[1, 10]]
```

```c++
class Solution {
public:
    static bool mysort(vector<int>& v1, vector<int>& v2) {
        if (v1[0] == v2[0]) {
            return v1[1] < v2[1];
        }
        return v1[0] < v2[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), mysort);
        vector<vector<int>> res;
        for (int i = 0; i < intervals.size(); i++) {
            int left = intervals[i][0], right = intervals[i][1];
            while (i + 1 < intervals.size() && right >= intervals[i + 1][0]) {
                i++;
                right = max(right, intervals[i][1]);
            }
            res.push_back(vector<int>{left, right});
        }
        return res;
    }
};
```

#### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

当且仅当每个相邻位数上的数字 x 和 y 满足` x <= y` 时，我们称这个整数是单调递增的。

给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈单调递增 。

```c++
10001 -> 9999
123320 -> 122999
```

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        //从前向后，遇到当前位小于前一位，不满足题干，将当前位设置成9，前一位减一即可。
        //但是前一位减一后，可能又小于它的前一位，因此从前向后方法不可
        //改成从后向前
        string str = to_string(n);
        int flag = str.size();
        for (int i = str.size() - 1; i > 0; i--) {
            if (str[i - 1] > str[i]) {
                flag = i;
                str[i - 1]--;
            }
        }
        for (int i = flag; i < str.size(); i++) {
            str[i] = '9';
        }
        return stoi(str);
    }
};
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。

**分析：难点在于，当前可卖出的价格是不是最终的价格。加入后面还有更高的价格，卖出时避免多减一次手续费。**

最优算法：**动态规划**

```c++
输入：prices = [1, 3, 4, 2， 8, 4, 9], fee = 2
输出：8
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int maxpro = 0;
        int minprice = prices[0];
        for (int i = 0; i < prices.size(); i++) {
            //买入更低价格股票
            if (prices[i] < minprice) minprice = prices[i];
            
            //持有
            else if (prices[i] > minprice + fee) {
                maxpro += prices[i] - minprice - fee;
                minprice = prices[i] - fee;
            }
        }
        return maxpro;
    }
};
```

#### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。

从下网上遍历，返回每一个节点的状态，空姐点设定为在监视范围内

执行用时：4 ms, 在所有 C++ 提交中击败了96.38%的用户

```c++
//一棵树有三个状态
//1.在监视范围内 2.安装摄像头 3.待监视状态
class Solution {
private:
    int nums;
public:
    int minCameraCoverFunc(TreeNode * root) {
        if (root == nullptr) {
            return 1;
        }
        int left = minCameraCoverFunc(root->left);
        int right = minCameraCoverFunc(root->right);
        if (left == 1 && right == 1) {
            return 3;
        } else if (left == 3 || right == 3) {
            nums++;
            return 2;
        } else {
            return 1;
        }
    }
    int minCameraCover(TreeNode* root) {
        nums = 0;
        if (minCameraCoverFunc(root) == 3) {
            nums++;
        }
        return nums;
    }
};
```

