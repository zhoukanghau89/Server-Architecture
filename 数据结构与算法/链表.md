# 链表

### 合并链表

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1) return list2;
    else if (!list2) return list1;
    else if (list1->val <= list2->val) {
        list1->next = mergeTwoLists(list1->next, list2);
        return list1;
    } else {
        list2->next = mergeTwoLists(list1, list2->next);
        return list2;
    }
}
```

### 排序链表

O(n logn) O(logn)

归并排序算法

合并两个链表

```cpp
class Solution {
public:
    ListNode* merge(ListNode * head1, ListNode * head2) {
        if (!head1) return head2;
        else if (!head2) return head1;
        else if (head1->val > head2->val) {
            head2->next = merge(head1, head2->next);
            return head2;
        }
        else  {
            head1->next = merge(head1->next, head2);
            return head1;
        }
    }
    ListNode* sortList(ListNode* head) {
        // 归并递归排序算法 O(nlogn) O(logn)
        if (!head || !head->next) return head;
        auto fast = head;  // 每次走两步
        auto slow = head;  // 每次走一步
        auto mid = head;   // 分割节点
        // 找到中间节点
        while (fast && fast->next) {
            fast = fast->next->next;
            if (!fast || !fast->next) mid = slow;
            slow = slow->next;
        }
        mid->next = nullptr;
        // 递归
        auto head1 = sortList(head);
        auto head2 = sortList(slow);
        // 合并两个有序链表
        return merge(head1, head2);
    }
};
```

