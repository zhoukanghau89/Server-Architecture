# 回溯算法 backtracking

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

步骤

- 回溯函数返回值、参数

先写逻辑，需要什么参数，就填哪个参数。参数能简单就简单。

- 终止条件

参考二叉树终止条件是叶子节点，达到临界值

- 遍历过程

回溯其实就是多层次的for循环，一般两层内的不需要回溯算法，三次及以上采用回溯算法。

### 组合题

#### [77. 组合](https://leetcode.cn/problems/combinations/)

优化算法：执行用时 0ms

先加入数组，再判断，满足条件加入结果数组中

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(int index, int n, int k) {
        if (tmp.size() == k) {
            res.push_back(tmp);
            return;
        } else if (index == n + 1) {
            return;
        }
        //n - i + 1 >= k - tmp.size() 数组剩余元素 >= 需要的剩余元素
        for (int i = index; i <= n - (k - tmp.size()) + 1; i++) {
            tmp.push_back(i);
            backtracking(i + 1, n, k);
            tmp.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(1, n, k);
        return res;
    }
};
```

**`2022/3/24`**

#### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

优化算法：执行用时 0ms

```c++
class Solution {
private:
    vector<string> str;
    vector<string> res;
    string tmp;
public:
    void backtracking(const string & digits, int index) {
        if (tmp.size() == digits.size()) {
            res.push_back(tmp);
            return;
        }
        for (int i = index; i < digits.size(); i++) {
            string s = str[digits[i] - '2'];
            for (int j = 0; j < s.size(); j++) {
                tmp.push_back(s[j]);
                backtracking(digits, i + 1);
                tmp.pop_back();
            }
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return res;
        }
        str = {"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};//[0,7]
        backtracking(digits, 0);
        return res;
    }
};
```

#### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

candidates数组中无重复元素，但组合中可出现重复元素

程序前加一个判断即可，若和值大于目标值，返回。

优化算法：执行用时 4ms，在所有 C++ 提交中击败了91.69%的用户

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(const vector<int>& candidates, int target, int sum, int index) {
        if (sum == target) {
            res.push_back(tmp);
            return;
        } else if (sum > target) {
            return;
        }
        for (int i = index; i < candidates.size(); i++) {
            if (sum + candidates[i] > target) {
                break;
            }
            tmp.push_back(candidates[i]);
            backtracking(candidates, target, sum + candidates[i], i);
            tmp.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        if (candidates[0] > target) {
            return res;
        }
        backtracking(candidates, target, 0, 0);
        return res;
    }
};
[2,3,5] 8
[[2,2,2,2],[2,3,3],[3,5]]
```

#### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates数组中存在重复元素，candidates 中的每个数字在每个组合中只能使用一次。

比39题稍作改动，解集中不能出现重复数组。

两个关键点：同一下标元素不可重复出现。

​                       不可出现重复答案。

同一下标不可重复出现解决：递归时取下一坐标的索引。

去重解决：三种方法

1. 最麻烦，编译可能通不过，对每一个找到的数组进行排序处理，在判断解集中是否已有此数组。

2. 设定一个vector存放bool数据，对应每个元素是否使用。正在数组中的bool为true。

```c++
c[i - 1] = true;  //同一树枝使用过，正在数组中
c[i - 1] = false; //同一数层使用过。
```

```c++
class Solution {
public:
    void backtracking(vector<int>& candidates, int target, vector<vector<int>>& vec,                           vector<int> v, int sum, int index, vector<bool> vb) {
        if (sum > target) return;
        if (sum == target) {
            vec.push_back(v);
            return;
        }
        for (int i = index; i < candidates.size(); i++) {
            if (i > 0 && candidates[i] == candidates[i - 1] && vb[i - 1] == false) continue;
            vb[i] = true;
            v.push_back(candidates[i]);
            backtracking(candidates, target, vec, v, sum + candidates[i], i + 1, vb);
            v.pop_back();
            vb[i] = false;
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> vec;
        vector<int> v;
        vector<bool> vb(candidates.size(), false);
        int index = 0;
        int sum = 0;
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, vec, v, sum, index, vb);
        return vec;
    }
};
```

3. 利用下标判断，判断同一数层是否使用过。

先排序，递归时如果当前元素的和大于目标值，说明以后的元素和都大于，直接跳过

优化算法：执行用时：4 ms, 在所有 C++ 提交中击败了89.99%的用户

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(const vector<int>& candidates, int target, int sum, int index) {
        if (sum == target) {
            res.push_back(tmp);
            return;
        }
        for (int i = index; i < candidates.size(); i++) {
            if (sum + candidates[i] > target) {
                return;
            } else if (i > index && candidates[i] == candidates[i - 1]) {
                continue;
            }
            tmp.push_back(candidates[i]);
            backtracking(candidates, target, sum + candidates[i], i + 1);
            tmp.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        if (candidates[0] > target) {
            return res;
        }
        backtracking(candidates, target, 0, 0);
        return res;
    }
};
```

4. 使用set去重

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            if (uset.find(candidates[i]) != uset.end()) continue;
            uset.insert(candidates[i]); // 记录元素
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1);
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        path.clear();
        result.clear();
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```



### 切割问题

`***2022/3/25***`

#### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

注意：此题并不是求所有的回文串，是将字符串全部分割成满足回文串的子串。

分析：依然送采用回溯法从头至尾遍历一遍，但其中的字符串如何分割是难点。

```c++
[index, i]； //就是要截取的z串
```

每一次判断截取的字串是否满足回文串，若不满足，此轮分割直接退出。

代码：

```c++
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

```c++
class Solution {
private:
    vector<vector<string>> res;
    vector<string> tmp;
public:
    void backtracking(const string & s, int index) {
        if (index == s.size()) {
            res.push_back(tmp);
            return;
        }
        for (int i = index; i < s.size(); i++) {
            //切割，判断是否未为回文子串
            string str = s.substr(index, i - index + 1);
            int left = 0, right = str.size() - 1;
            bool ret = true;
            while (left < right) {
                if (str[left++] != str[right--]) {
                    ret = false;
                    break;
                }
            }
            if (ret == false) {
                continue;
            }

            tmp.push_back(str);
            backtracking(s, i + 1);
            tmp.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        backtracking(s, 0);
        return res;
    }
};
```



#### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 隔开

分析：

首先想到回溯法，因为需要切割字符串。

设定`nums`来记录截取的字符串数目

先写递归内容：每一次截取`[index, i]`个字符串，首先判断截取的字符串个数是否在`[0, 3]`之间，再判断字符串数值大小是否在`[0, 255]`区间，都满足将字符串压入到IP地址中。

再写终止条件：1. 截取的字符串的字符个数大于3或者0开头的无效IP

2. 当截取完四个，且无剩余字符，说明符合条件的Ip。

再填充递归函数参数即可。

优化算法：执行用时：0 ms，在所有 C++ 提交中击败了100.00%的用户

```c++
class Solution {
private:
    vector<string> res;
    string tmp;
public:
    void backtracking(const string & s, int index, int nums) {
        if (index == s.length() && nums == 4) {
            tmp.pop_back();
            res.push_back(tmp);
            tmp += '.';
            return;
        }
        for (int i = index; i < s.size(); i++) {
            if (s.size() - i > (4 - nums) * 3) {
                continue;
            }
            string str = s.substr(index, i - index + 1);
            if (str.size() > 1 && str[0] == '0' || str.size() > 3) {
                return;
            } else if (stoi(str) > 255) {
                continue;
            }
            tmp += str + '.';
            backtracking(s, i + 1, nums + 1);
            tmp.resize(tmp.size() - str.size() - 1);
        }
    }
    vector<string> restoreIpAddresses(string s) {
        backtracking(s, 0, 0);
        return res;
    }
};
```

### 子集问题

**力扣78题**  

给定数组不含重复元素。返回所有子集，不包含重复子集。

无需做去重处理，因为给定数组不包含重复元素。

```C++
class Solution {
public:
    void backtracking(const vector<int>& nums, vector<vector<int>>& vec, vector<int> v, int index) {
        if (index == nums.size()) return;
        for (int i = index; i < nums.size(); i++) {
            v.push_back(nums[i]);
            vec.push_back(v);
            backtracking(nums, vec, v, i+1);
            v.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> vec;
        vector<int> v;
        vec.push_back(v);
        int index = 0;
        backtracking(nums, vec, v, index);
        return vec;
    }
};
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

#### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

给定数组中包含重复元素。返回所有子集，不能包含重复子集。

去重：同一数层元素不可重复。同一树枝元素可以重复。

执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(const vector<int>& nums, int index) {
        for (int i = index; i < nums.size(); i++) {
            if (i > index && nums[i] == nums[i - 1]) {
                continue;
            }
            tmp.push_back(nums[i]);
            res.push_back(tmp);
            backtracking(nums, i + 1);
            tmp.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        res.push_back(tmp);
        backtracking(nums, 0);
        return res;
    }
};
```

#### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况

**分析**：这道题坑比较多。子集不能有重复答案；本体是自增系列，不可对其排序；且可能一段递增，再重新来一段递增，且存在元素相等情况，也视作递增情况；子集可不是连续的

思路：**本体可以用哈希表，同一树层间采用哈希结构，同一树枝对重复元素无要求（重复元素视作递增）**

```c++
[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]
```

```C++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(const vector<int> & nums, int index) {
        if (tmp.size() >= 2) {
            res.push_back(tmp);
        }
        unordered_set<int> used;
        for (int i = index; i < nums.size(); i++) {
            if (used.find(nums[i]) != used.end()) {
                continue;
            }
            used.insert(nums[i]);
            if (tmp.size() == 0 || nums[i] >= tmp[tmp.size() - 1]) {
                tmp.push_back(nums[i]);
                backtracking(nums, i + 1);
                tmp.pop_back();
            }
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return res;
    }
};
```

### 排列问题

#### [46. 全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 所有可能的全排列 。你可以 **按任意顺序** 返回答案。

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

分析：找出所有的排列组合，要求用所有的元素。每一次从头遍历，难点在如何标记当前严肃是否已经使用。

两种方法：

1. 使用哈希表 `unordered_set<int>`，set中不可存放重复元素
2. 设定一个`vector<bool> vb(nums.size(), false)`数组，未使用的用false表示，已经使用的用true

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
    unordered_set<int> used;
public:
    void backtracking(const vector<int> & nums) {
        if (tmp.size() == nums.size()) {
            res.push_back(tmp);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            auto it = used.find(nums[i]);
            if (it != used.end()) {
                continue;
            }
            used.insert(nums[i]);
            tmp.push_back(nums[i]);
            backtracking(nums);
            tmp.pop_back();
            it = used.find(nums[i]);
            used.erase(it);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        backtracking(nums);
        return res;
    }
};
```

#### [47. 全排列 II（重点）](https://leetcode.cn/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

```c++
输入：nums = [1,1,2]
输出：[[1,1,2],[1,2,1],[2,1,1]]
```

 分析：三种情况重复

1. 同一树枝重复 允许发生
2. 同一树层重复 无效，跳过

**去重化**：

1. 设定`vector<bool> vb(nums.size(), false)`数组，若同一树枝元素重复，允许。若同一树层元素重复，则是重复发全排列，跳过。**去重：当前元素与前一元素相等，且前一元素当前状态未使用，说明相应树枝使用过，跳过。**

执行用时：4 ms, 在所有 C++ 提交中击败了91.90%的用户

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(const vector<int>& nums, vector<bool> & used) {
        if (tmp.size() == nums.size()) {
            res.push_back(tmp);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            //记录不同树枝，若树枝相同，跳过
            if (i > 0 && nums[i] ==  nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //同一树层，记录是否使用过，保证每个元素仅使用一次
            if (used[i] == false) {
                used[i] = true;
                tmp.push_back(nums[i]);
                backtracking(nums, used);
                used[i] = false;
                tmp.pop_back();
            }
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return res;
    }
};
```

2. vector<bool>记录同一树层，保证每个元素仅用一次；unordered_set<int>记录不同的树枝，若相同树枝则跳过

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> tmp;
public:
    void backtracking(const vector<int>& nums, vector<bool> & used) {
        if (tmp.size() == nums.size()) {
            res.push_back(tmp);
            return;
        }
        unordered_set<int> uset;
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) {
                continue;
            } else if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            used[i] = true;
            uset.insert(nums[i]);
            tmp.push_back(nums[i]);
            backtracking(nums, used);
            used[i] = false;
            tmp.pop_back();
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return res;
    }
};
```

**2022/3/26**

**力扣332 题重新安排行程**

给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

输入：`tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]`
输出：`["JFK","ATL","JFK","SFO","ATL","SFO"]`

输入：`[["JFK","KUL"],["JFK","NRT"],["NRT","JFK"]]`

输出：`["JFK", "NRT", "JFK", "KUL"]`

unordered_map<出发机场， map<到达机场，航班次数>>  通过航班次数的增减标记机场是否使用过。

执行用时：16 ms, 在所有 C++ 提交中击败了82.24%的用户

```c++
class Solution {
private:
    vector<string> res;
    unordered_map<string, map<string, int>> umap;
    bool ret;
public:
    void backtracking(const vector<vector<string>>& tickets, string str) {
        if (res.size() == tickets.size() + 1) {
            ret = true;
            return;
        }
        for (auto it = umap[str].begin(); it != umap[str].end(); it++) { //for (auto & it : umap)
            if (it->second) {
                res.push_back(it->first);
                it->second--;
                backtracking(tickets, it->first);
                if (ret) { //找到目标行程，立即返回
                    return;
                } else { //没找到，继续回溯，说明当前航线不对
                    res.pop_back();
                    it->second++;
                }
            }
        }
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (auto t : tickets) {
            umap[t[0]][t[1]]++;
        }
        ret = false;
        res.push_back("JFK");
        backtracking(tickets, "JFK");
        return res;
    }
};
```

### 棋盘问题

#### [51. N 皇后](https://leetcode.cn/problems/n-queens/)

n皇后问题是指一个在n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两两均不在同一行、同一列、同一条对角线上，求合法的方案数。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```c++
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
```

思路：采用回溯法，皇后的同一行、同一列、同一条对角线（左右两条）均不可以

设定一个`vector<vector<bool>>`存放每个位置是否可以放子

每一次设置皇后位置前，判断同一列、左对角、右对角是否有皇后

优化算法：执行用时：8 ms, 在所有 C++ 提交中击败了51.67%的用户

```c++
class Solution {
private:
    vector<vector<string>> res;
    vector<string> tmp;
public:
    void backtracking(int n, int index, vector<vector<bool>>& used) {
        if (tmp.size() == n) {
            res.push_back(tmp);
            return;
        }
        for (int i = 0; i < n; i++) {
            bool ret = false;
            for (int row = index - 1; row >= 0; row--) {
                if (used[row][i]) {
                    ret = true;
                    break;
                }
            }
            if (ret) {
                continue;
            }
            for (int row = index - 1, col = i - 1; row >= 0 && col >= 0; row--,col--) {
                if (used[row][col]) {
                    ret = true;
                    break;
                }
            }
            if (ret) {
                continue;
            }
            for (int row = index - 1, col = i + 1; row >=0 && col < n; row--, col++) {
                if (used[row][col]) {
                    ret = true;
                    break;
                }
            }
            if (ret) {
                continue;
            }
            used[index][i] = true;
            string str(n, '.');
            str[i] = 'Q';
            tmp.push_back(str);
            backtracking(n, index + 1, used);
            tmp.pop_back();
            used[index][i] = false;
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<bool>> used(n, vector<bool>(n, false));
        backtracking(n, 0, used);
        return res;
    }
};
```

#### [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

```C++
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

思路：回溯，每个位置从`[1, 9]`试一遍，逐一遍历，成功返回。失败就将当前数字更换。重新回溯。

算法返回值为bool类型，遇到合适的就返回。不合适返回false，将当前数字更换，重新遍历。

```c++
class Solution {
public:
    bool isValid(char c, int row, int col, const vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) 
            if (board[row][i] == c) return false;
        for (int j = 0; j < 9; j++) 
            if (board[j][col] == c) return false;
        //确定所在九宫格子
        row = (row / 3) * 3;
        col = (col / 3) * 3;
        for (int i = row; i < row + 3; i++) {
            for (int j = col; j < col + 3; j++)
                if (board[i][j] == c) return false;
        }
        return true;
    }
    //返回值要选bool类型的，知道满足条件的可直接返回，因为不能传坐标参数，用bool判断。
    bool backtracking(vector<vector<char>>& board) {
        //二维回溯，不能传做坐标参数
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[i].size(); j++) {
                if (board[i][j] != '.') continue;
                for (char c = '1'; c <= '9'; c++) {
                    if (isValid(c, i, j, board)) {
                        board[i][j] = c;
                        if (backtracking(board)) return true;
                        board[i][j] = '.';
                    }
                }
                return false;  //9个数都不能满足说明上一位数字错误
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```

#### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

```c++
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```



```c++
class Solution {
private:
    vector<string> res;
    string str;
public:
    void backtracking(int n, int cur) {
        if (str.size() == n * 2) {
            res.push_back(str);
            return;
        }
        if (cur < n) {
            str.push_back('(');
            backtracking(n, cur + 1);
            str.pop_back();
        }
        if (str.size() - cur < cur) {
            str.push_back(')');
            backtracking(n, cur);
            str.pop_back();
        }
    }
    vector<string> generateParenthesis(int n) {
        str = "";
        backtracking(n, 0);
        return res;
    }
};
```

