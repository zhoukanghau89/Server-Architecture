# 滑动窗口

算法一般要求

满足”   “条件（计算结果、出现次数、同时包含）

最长/最短

子串/子数组/子序列

必须是连续的



核心思想——寻找最长

双指针L、R均在起始点，R向右逐一循环

每次滑动中

如果窗内的元素满足条件，R向右扩大窗口，并获得最新结果

如果窗内的元素不满足条件，L向右缩小窗口

结束：R到达右边界

```c++
// 初始化left,right,result, bestresult
while (right < 右边界) {
    // 窗口扩大，加入right对应元素更新当前result
    while (result不满足要求) {
        // 窗口缩小，移除left对应元素，left右移
    }
    // 更新best result
    right++;
}
```



核心思想——寻找最短

双指针L、R均在起始点，R向右逐一循环

每次滑动中

如果窗内的元素满足条件，L向右缩小窗口，并获得最新结果

如果窗内的元素不满足条件，R向右扩大窗口

结束：R到达右边界

```c++
// 初始化left,right,result, bestresult
while (right < 右边界) {
    // 窗口扩大，加入right对应元素更新当前result
    while (result满足要求) {
        // 更新best result
        // 窗口缩小，移除left对应元素，left右移
    }
    right++;
}
```



#### 209. 长度最小的子数组

找出数组中满足和`sum >= target`的长度最小的连续子数组，不存在返回0

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int right = 0;
        int cursum = 0;
        int result = INT_MAX;
        int n = nums.size();
        while (right < n) {
            cursum += nums[right];
            while (cursum >= target) {
                result = min(result, right - left + 1);
                cursum -= nums[left++];
            }
            right++;
        }
        if (result == INT_MAX) return 0;
        return result;
    }
};
```

#### 30. 串联所有单词的子串



#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

#### [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

#### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```c++
s = "cbaebabacd", p = "abc"
```

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char, int> m;
        for (const auto & c : p) {
            m[c]++;
        }
        vector<int> res;
        int left = 0;
        int right = 0;
        while (right < s.size()) {
            // 字符不存在目标字符串中
            if (m.find(s[right]) == m.end()) {
                while (left < right) {
                    m[s[left]]++;
                    left++;
                }
                right++;
                left = right;
            } else {
                // 当前字符串中的当前字符个数多余目标字符串中的
                while (left < right && m[s[right]] - 1 < 0) {
                    m[s[left]]++;
                    left++;
                }
                m[s[right]]--;
                right++;
                // 找到字母异位词
                if (right - left == p.size()) {
                    res.push_back(left);
                    // 将窗口右移一位
                    m[s[left]]++;
                    left++;
                }
            }
        }
        
        return res;
    }
};
```



#### 239. 滑动窗口最大值

```c++
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```

单调队列实现（降序）

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> st;
        int i = 0;
        //第一次先走到窗口右边界
        while (i < nums.size() && i < k - 1) {
            while (!st.empty() && nums[st.back()] < nums[i]) {
                st.pop_back();
            }
            st.push_back(i++);
        }
        int left = 0;
        //开始滑动窗口
        for (; i < nums.size(); i++) {
            //窗口内的队列采用降序，即从后往前判断，比当前值小的删除
            while (!st.empty() && nums[st.back()] < nums[i]) {
                st.pop_back();
            }
            st.push_back(i);
            res.push_back(nums[st.front()]);
            //移动窗口，若当前最大值是左边界
            if (st.front() == left) {
                st.pop_front();
            }
            left++;
        }
        return res;
    }
};
```

#### 1044. 最长重复子串



