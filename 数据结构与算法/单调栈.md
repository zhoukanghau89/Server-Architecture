# 单调栈、单调队列

单调栈通常解决在数组或队列中寻找在当前元素的左边或者右边第一位比当前元素大的元素

可以理解成是一个一位数组，存放这些元素

**2022/4/9**

#### 力扣42 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```cpp
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
```

![image-20220409103232260](C:\Users\zhouk\AppData\Roaming\Typora\typora-user-images\image-20220409103232260.png)

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int len = height.size();
        if (len < 3) return 0;  //小于3直接退出，无法接雨水
        int ans = 0;
        vector<int> v;   //单调栈，保存递减元素，寻找第一位比当前y
        v.push_back(0);
        for (int i = 1; i < len; i++) {
            //当前元素只要比栈顶大就有接雨水的可能，一直判断到当前元素小于等于栈顶元素
            if (height[i] > height[v[v.size() - 1]]) {
                int nums = 0;
                while (v.size() && height[i] > height[v[v.size() - 1]]) {
                    int index = v[v.size() - 1];   //接雨水底部坐标
                    //找到接雨水的左右两个墙壁，第一个是当前元素
                    while (v.size() && height[index] == height[v[v.size() - 1]]) {
                        v.pop_back();
                    }
                    //如果为空，没有墙壁退出当前循环
                    if (v.size() == 0) break;
                    //找到墙壁，统计底部宽度
                    nums += index - v[v.size() - 1];
                    //计算能接的雨水量
                    ans += nums * (min(height[v[v.size() - 1]], height[i]) - height[index]);
                    // if (height[v[v.size() - 1]] >= height[i]) {
                    //     ans += nums * (height[i] - height[index]);
                    // }
                    // else {
                    //     ans += nums * (height[v[v.size() - 1]] - height[index]);
                    // }
                }
            }
            //将当前元素加入栈中
            v.push_back(i);
        }
        return ans;
    }
};
```

#### 力扣84 柱状图中最大的矩形

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

```cpp
输入：heights = [2,1,5,6,2,3]
输出：10
```

![image-20220409134151908](C:\Users\zhouk\AppData\Roaming\Typora\typora-user-images\image-20220409134151908.png)

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        //最大面积，可以是多块组成的，也可以是本身，只要覆盖面积最大即可。选择单调栈
        //栈中保存递增元素，寻找第一位比当前元素小的元素
        //覆盖区间就是当前元素的数值 * 宽度（大于等于当前元素）
        vector<int> v;
        v.push_back(0);
        int maxArea = 0;
        //头尾加0，方便寻找区间
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        int len = heights.size();
        for (int i = 1; i < len; i++) {
            while (v.size() && heights[i] < heights[v[v.size() - 1]]) {
                int index = v[v.size() - 1];
                v.pop_back();
                //宽度(v[v.size() - 1], i)
                maxArea = max(maxArea, heights[index] * (i - v[v.size() - 1] - 1));
            }
            v.push_back(i);
        }
        return maxArea;
    }
};
```

#### 力扣239滑动窗口最大值

单调递减队列

```cpp
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        //单调队列，存放数组下标
        vector<int> result;
        deque<int> q;
        int n = 0;
        for (int i = 0; i < nums.size(); i++) {
            n++;
            while (!q.empty() && nums[q.back()] <= nums[i]) q.pop_back();
            q.push_back(i);
            while (!q.empty() && q.front() <= i - k) q.pop_front();
            if (n == k) {
                result.push_back(nums[q.front()]);
                n--;
            }
        }
        return result;
    }
};
```

