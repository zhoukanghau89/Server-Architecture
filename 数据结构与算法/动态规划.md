# 动态规划 Dynamic Programming

**2022/3/30**

实质：每一个状态都是由上一个状态推导出来的。

多举例子。找出其中的规律，确定递推公式。

注意`dp[]`数组的长度，不考虑坐标为0的情况，一般是`n + 1`

解释以下为什么是`n +  1`，因为动态规划是参考前一步的结果，下标要从1开始，而字符串下标是从0开始，如果`dp`数组的长度与字符串相同，遍历到字符串末尾时，`dp`数组实际上已经到`n+1`位置了，会产生下标的数组越界。

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

给定n，求由1到n个节点组成的二叉搜索树的种类，树中不可以有重复元素。

拆分成：左子树与右子树的种类数目乘机

一共`i`个节点：左子树加父节点一共`j`个，右子树有`i - j`个，左子树有`j - 1`个节点，遍历`j`从1到`i`即可

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            } 
        }
        return dp[n];
    }
};
```

```c++
输入：n = 3
输出：5
```

**2022/3/31**

## 背包问题

### 01背包

给定一堆食物，其重量与价值均已知，给定一个背包容量，求背包最多能装食物的价值。

解法一：

二维数组 `dp[i][j]`表示当背包容量为`j`时，从下标`[0, i]`中可以拿到的最大价值。

递推公式：动态规划是根据前一时刻得出当前状态，因此都是在`i - 1`的基础上

1.不放入新物品，背包不放入物品`i`的价值，就是前一时刻的价值，此时`dp[i][j] = dp[i - 1][j]`

2.放入新物品，此时需要将当前背包容量减去`weight[i]`，背包质量加上`value[i]`，此时`dp[i][j] = dp[i - 1][j - weight[i]] + value[i]`

初始化，`j = 0`时，价值为0

代码：

```C++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;
    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }
    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }
}
```

解法二：

一维数组

`dp[i -1][j]`其实就是上一轮的`dp[i][j]`，用一维数组也可以解决问题。

遍历顺序需要倒叙，想不明白就举例子。

初始化都是0

还是上面那个例子，假如正序遍历。`i = 0，dp[1] = max(dp[1], dp[1 - weight[1]] + value[1]) = 15`

`dp[2] = max(dp[2], dp[2 - weight[1]] + value[1]) = max(15, 15 + 15) = 30`

可以发现，物品0被放入了两次，所以不能正序遍历。

遍历条件，由于是倒叙遍历，每次从背包容量最大开始，条件是大于等于物品i的重量，因为小于物品i的话，没有比较意义，无法放入，此时的dp[j]就是上一轮的答案。

外层for循环是物品遍历顺序，内层for循环是背包容量。

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;
    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 只包含正整数的非空数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**分析：将数组求和，在数组中判断是否存在元素相加和为数组和的一半。**

背包问题，此题中数组的值就是食物的价值，也是食物的重量。

`dp`数组的长度就是`sum + 1`，`weight[i] = value[i]`，想明这些就好做了，就是背包问题的做法。

代码：

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (sum % 2 != 0) return false;
        sum /= 2;
        int n = nums.size();
        vector<int> dp(sum + 1, 0);
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; i++) {
            for (int j = sum; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[sum] == sum;
    }
};
```

#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

**思路：任意选`i`块石头，使得重量加起来趋近于总重量的一半，因为这样和另一半的抵消的差值就是最小的。**

还是背包问题，在`sum/2`的背包中找出价值最大的食物。

此题的食物的重量与价值相同。

```C++
输入：stones = [31,26,33,21,40]
输出：5
```

```C++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        if (stones.size() == 1) return stones[0];
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        int target = sum;
        sum /= 2;
        vector<int> dp(sum + 1, 0);
        for (int i = 0; i < stones.size(); i++) {
            for (int j = sum; j >= stones[i]; j--) {
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return (target - dp[sum]) - dp[sum];
    }
};
```

**总结：凡是求数组中一半元素和的问题，都是动态规划**

#### [494. 目标和-组合问题](https://leetcode.cn/problems/target-sum/)

求运算结果等于`target`的表达式的数目。

首先对数组求和`sum`。

问题转换为：找到一个正数集合与负数集合，使其相加和为`target`。

`sum(P) - sum(N) = target`

`sum(N) = sum(nums) - sum(P)`

`sum(P) = (sum(nums) + target) / 2`

1. 回溯代码：

```cpp
class Solution {
public:
    int count;
    void backtracking(vector<int>& nums, int target, int index, int sum) {
        if (sum == target) count++;
        for (int i = index; i < nums.size(); i++) {
            sum += nums[i];
            if (sum > target) break;
            backtracking(nums, target, i + 1, sum);
            sum -= nums[i];
        }
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if ((sum + target) % 2 != 0) return 0;
        target = (sum + target) / 2;
        sort(nums.begin(), nums.end());
        count = 0;
        backtracking(nums, target, 0, 0);
        return count;
    }
};
```

2. 动规做法

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        //sump - sumn = tar, sump - (sum - sump) = tar
        //sump = (tar + sum)/2;
        int sum = 0;
        for (auto & x : nums) {
            sum += x;
        }
        //容量大于背包总和，或者永远装不满
        if (abs(target) > sum || (sum + target) % 2 == 1) {
            return 0;
        }
        int sump = (sum + target) / 2;
        vector<vector<int>> dp(nums.size() + 1, vector<int>(sump + 1, 0));
        dp[0][0] = 1; //装满容量为0的背包，装0件商品，有一种方法
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j <= sump; j++) {
                if (j < nums[i]) {
                    dp[i + 1][j] = dp[i][j];
                } else {
                    //装满容量为j的背包，可以不放入当前元素 + 放入当前元素,装满容量为j-nums[i]
                    dp[i + 1][j] = dp[i][j] + dp[i][j - nums[i]];
                }
            }
        }
        return dp[nums.size()][sump];
    }
};
```



#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

给定一个字符串数组strs，字符串都是二进制数，找出strs的最大子集长度，子集中最多有m个0，n个1。

乍一看与背包问题，没什么关系。其实就是一个二维背包问题，此题的m与n均为背包，每个字符串就是物品。这是一个`m*n`大小的背包，每个物品的大小为`sum(0)*sum(1)`，每个物品的价值与尺寸相等，意味着在这个背包中找出最大的物品价值的物品个数。

`dp[i][j]`表示，最多有i个0，j个1的最大strs子集的大小。

递推公式：背包问题是`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

此题的递推公式`dp[i][j] = max(dp[i][j], dp[i - nums0][j - nums1] + 1)`

```c++
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
```

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (auto str : strs) {
            int nums0 = 0, nums1 = 0;
            for (auto c : str) {
                if (c == '0') nums0++;
                else nums1++;
            }
            if (nums0 > m || nums1 > n) continue;
            for (int i = m; i >= nums0; i--) {
                for (int j = n; j >= nums1; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - nums0][j - nums1] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

**2022/4/1**

### 完全背包

与01背包的区别在于完全背包中每一件商品的个数没有限制。

可以无限次的装任何一件商品，此时的内层背包的遍历顺序是正序遍历，因为可以重复装

内层遍历时，不需要从0开始，因为当背包容量小于商品重量时，背包不放入当前商品，与上一轮的结果相同。

```cpp
void test_CompletePack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```

#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

给定`coins = [1, 2, 5]`表示不同面值的硬币，求满足总金额`amount`的硬币组合数目。

求装满背包有几种方法，一般公式都是`dp[j] += dp[j - nums[i]]`（无论是组合还是排列）

遍历顺序：纯完全背包问题是能否凑成总和，本题是求凑出总和的组合数。

**先遍历物品，再遍历背包**

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        //设定dp数组 dp[j]表示总金额为j的硬币组合数目
        vector<int> dp(amount + 1, 0);
        //外层for循环是硬币遍历顺序，内层for循环是硬币总金额的遍历顺序，正序遍历
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
amount = 5
out = 4
```

若先遍历背包容量，再遍历硬币金额， 求解的是**排列组合数**。

```cpp
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
amout = 5;
out = 8;
```

#### [377. 组合总和 Ⅳ【排列】](https://leetcode.cn/problems/combination-sum-iv/)

c++测试用例 用两个数相加和大于`int`最大值的情况，所以要加个判断语句。

**排列组合问题。**

`nums = [1, 2, 3] target = 4`

`dp[j]`表示总和为`j`时，有多少种排列。

`dp[j - nums[i]]`表示去掉`nums[i]`剩下的有几个排列。

**遍历顺序：先遍历背包，再遍历物品。如果先遍历物品，如计算dp[4]的时候，1永远在3的前边，不会有{3，1}解**

```C++
j == 1 //只有一种1
j == 2 //11、2
j == 3 //111、12、21、3
j == 4 //去掉一个1[111,12,21,3]、去掉一个2[11,2]、去掉一个3[1]
```

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int j = 0; j <= target; j++) {   //遍历背包
            for (int i = 0; i < nums.size(); i++) {   //遍历物品
                if (j - nums[i] >= 0 && dp[j] < INT_MAX - dp[j - nums[i]])
                    dp[j] += dp[j - nums[i]];
            }
        }
        return dp[target];
    }
};
```

#### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

给定硬币数组`coins`和总金额`amount`，求出能够凑成总金额所需的最小的硬币数目。若没有能凑成的，返回-1

分析：`dp[j]`凑足金额为`j`所需金币的最小个数。

递推公式：

**`dp[j]`唯一来源`dp[j - coins[i]]`，凑足总额为`j - coins[i]`的最少个数为`dp[j - coins[i]]`，那么只需要加上一个钱币`coins[i]`即`dp[j - coins[i]] + 1`就是`dp[j]`（考虑`coins[i]`）**

**所以``dp[j] `要取所有` dp[j - coins[i]] + 1 `中最小的就是“答案”。**

递推公式：`dp[j] = min(dp[j - coins[i]] + 1, dp[j])`

```c++
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j - coins[i]] == INT_MAX) {
                    continue;
                }
                dp[j] = min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

**2022/4/2**

#### 力扣139 最长回文子串

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```c++
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
```

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        //背包问题，背包中的食物是固定的，给定一堆食物，问背包中的食物是否都有
        //字符串的长度就是背包的容量
        //`dp[i] = true`表示字符串长度为i时，可由字典中的单词拼凑成
        //初始化均为false,d[0] = true，字符串长度为0也视作可以
        //外层背包，内层物品
        //每一次减去当前字典长度的字符，若剩余的d[j] = true 且 减掉的这个子字符串出现在字典中，为true
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < wordDict.size(); j++) {
                if (wordDict[j].size() <= i) {
                    string word = s.substr(i - wordDict[j].size(), wordDict[j].size());
                    if (wordSet.find(word) != wordSet.end() && 
                        dp[i - wordDict[j].size()]) {
                        dp[i] = true;
                    }
                }
            }
        }
        return dp[s.size()];
    }
};
```

**2022/4/25**

#### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

遍历顺序，先背包在物品

```c++
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
```

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < wordDict.size(); j++) {
                int n = wordDict[j].size();
                if (n > i) {
                    continue;
                }
                if (s.substr(i - n, n) != wordDict[j]) {
                    continue;
                }
                dp[i] = dp[i] || dp[i - n];
            }
        }
        return dp[s.size()];
    }
};
```

### 打家劫舍系列【用不用的问题】

**2022/4/3**

#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

在上一题基础上，讲数组设置为环状数组，头尾是连接的，即若在头部拿元素，尾部就不允许

分两步走：不要首元素、不要尾元素，比较最大值

```c++
输入：nums = [1,2,3,1]
输出：4
```

```c++
class Solution {
public:
    int robFunc(vector<int>& nums, int start, int n) {
        vector<int> dp(nums.size() + 1, 0);
        dp[start + 1] = nums[start];
        for (int i = start + 1; i < start + n; i++) {
            dp[i + 1] = max(dp[i], dp[i - 1] + nums[i]);
        }
        return dp[start + n];
    }
    int rob(vector<int>& nums) {
        if (nums.size() == 1) {
            return nums[0];
        }
        return max(robFunc(nums, 0, nums.size() - 1), robFunc(nums, 1, nums.size() - 1));
    }
};
```

#### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

二叉树，根节点开始，不允许连续取值两个节点，求最大取值和。

树形动规的入门题目。

```cpp
输入: root = [3,2,3,null,3,null,1]
输出: 7 
```

```cpp
//暴力搜索法
class Solution {
public:
    //采用map数组保存遍历过的节点，否则超时
    unordered_map<TreeNode*, int> mmap;
    int rob(TreeNode* root) {
        if (!root) return 0;
        if (mmap[root]) return mmap[root];
        if (!root->left && !root->right) return root->val;
        //不用当前节点
        int val1 = 0;
        val1 += rob(root->left) + rob(root->right);
        //用当前节点
        int val2 = root->val;
        if (root->left) val2 += rob(root->left->left) + rob(root->left->right);
        if (root->right) val2 += rob(root->right->left) + rob(root->right->right);
        mmap[root] = max(val1, val2);
        return max(val1, val2);
    }
};
//动态规划
class Solution {
public:
    //重点！vector<int> 长度为2，保存每个节点用不用得到的结果
    //当不用当前节点，他的大小取决于左右孩子分别用不用自己节点的最大值（当前节点不用，孩子就随便用了）
    //当前节点用：当前节点 + 左右孩子不用的值
    vector<int> robTree(TreeNode* root) {
        if (!root) return vector<int>{0, 0};
        vector<int> left = robTree(root->left);
        vector<int> right = robTree(root->right);
        return vector<int>{max(left[0], left[1]) + max(right[0], right[1]), 
                            root->val + left[0] + right[0]};
    }
    int rob(TreeNode* root) {
        //找出二叉树中节点和的最大值，任意两个节点不能相连
        //记录每个节点的状态，用或者不用，用的话两个孩子就不能用
        //dp[0]：不用； dp[1]：用
        vector<int> dp = robTree(root);
        return max(dp[0], dp[1]);
    }
};
```

## 买股票问题

#### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**2022/4/26更新动态规划**

`dp[i][j]`：在第i天，股票的状态（不操作、买入、卖出），每一个状态都是由前一天的状态推导出来的

`dp[i][1]`两种情况：

1. 没有操作，延续上一天的`dp[i - 1][1]`
2. 买操作，上一天的无操作减掉当天的价格 `dp[i - 1][0] - prices[i]`

`dp[i][2]`两种情况：

1. 没有操作，延续上一天的`dp[i - 1][2]`
2. 卖操作，上一天的买入操作加上当天的价格`dp[i - 1][1] + prices[i]`

后续同理

|          | 状态 | 不操作 | 第一次买入 | 第一次卖出 | 第二次买入 | 第二次卖出 |
| -------- | ---- | ------ | ---------- | ---------- | ---------- | ---------- |
| 股票价格 | 下标 | 0      | 1          | 2          | 3          | 4          |
| 3        | 0    | 0      | -3         | 0          | -3         | 0          |
| 3        | 1    | 0      | -3         | 0          | -3         | 0          |
| 5        | 2    | 0      | -3         | 2          | -3         | 2          |
| 0        | 3    | 0      | 0          | 2          | 2          | 2          |
| 0        | 4    | 0      | 0          | 2          | 2          | 2          |
| 3        | 5    | 0      | 0          | 3          | 2          | 5          |
| 1        | 6    | 0      | 0          | 3          | 2          | 5          |
| 4        | 7    | 0      | 0          | 4          | 2          | 6          |

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = dp[0][3] = 0 - prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

**2022/4/26二刷代码随想录，动态规划方法**

`dp[i][2 * j - 1]`两种情况：

1. 没有操作，延续上一天的`dp[i - 1][2 * j - 1]`
2. 买操作，上一天的无操作减掉当天的价格 `dp[i - 1][2 * j - 2] - prices[i]`

`dp[i][2 * j]`同样两种情况：

1. 没有操作，延续上一天的`dp[i - 1][2 * j]`
2. 卖操作，上一天的买入操作加上当天的价格`dp[i - 1][2 * j - 1] + prices[i]`

```cpp
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
```

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.size() == 0 || k == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int i = 1; i <= k; i++) dp[0][2 * i - 1] = - prices[0];
        for (int i = 1; i < prices.size(); i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][2 * j - 1] = max(dp[i - 1][2 * j - 1], dp[i - 1][2 * j - 2] - prices[i]);
                dp[i][2 * j] = max(dp[i - 1][2 * j], dp[i - 1][2 * j - 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

**2022/4/4**

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

根据题干，可将每一天的状态设置三种，买入、卖出、冷冻期

```cpp
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(n, vector<int>(3, 0));
        //dp[i][0] 买入状态（不一定非得是今天买的，相当于持有状态）
        //dp[i][1] 卖出状态
        //dp[i][2] 冷冻期状态
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            //前一天的买入、前一天为冷冻期，今天买入
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
            //前一天的卖出，将前一天的持有卖出
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            //前一天的卖出状态、前一天的冷冻期状态
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]);
        }
        return dp[prices.size() - 1][1];//返回当前卖出状态即是最大利润状态
    }
};
```

**2022/4/26二刷**

每一天有三个状态，买入、卖出、冷静期（包括不买不卖状态）

买入两种情况：延续前一天的买入状态、以前一天的冷静期买入

卖出两种情况：延续前一天的卖出状态、将前一天的持有卖出

冷静期两种情况：延续前一天的冷静状态（不卖不卖）、前一天的卖出今天刚好是冷静期

|          | 状态 | 买入 | 卖出 | 冷静期 |
| -------- | ---- | ---- | ---- | ------ |
| 股票价格 | 下标 | 1    | 2    | 4      |
| 1        | 0    | -1   | 0    | 0      |
| 2        | 1    | -1   | 1    | 0      |
| 3        | 2    | -1   | 2    | 1      |
| 0        | 3    | 1    | 2    | 2      |
| 2        | 4    | 1    | 3    | 2      |



#### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

在正常买卖基础上加上了股票的手续费

```cpp
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
```

**2022/4/26二刷**

每一天的有两个状态：买入或者卖出（包括不买不卖）

买入：延续前一天的买入状态或者前一天的持有减去当前的价格

卖出：不买不卖或者将前一天的持有股票卖出

|      | 状态 | 买入 | 卖出 |
| ---- | ---- | ---- | ---- |
| 股票 | 下标 | 0    | 1    |
| 1    | 0    | -1   | 0    |
| 3    | 1    | -1   | 0    |
| 2    | 2    | -1   | 0    |
| 8    | 3    | -1   | 5    |
| 4    | 4    | 1    | 5    |
| 9    | 5    | 1    | 8    |

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = 0 - prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.size() - 1][1];
    }
};
```

#### 股票问题总结篇

买卖一次到买卖多次

从最多买卖两次到最多买卖`K`次

从冷冻期再到手续费

## 字符串系列

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度

```c++
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4
```

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        //dp[i]含义：[0, i]区间内以nums[i]结尾的最长递增子序列的长度
        //递推公式：遍历[0, i - 1]区间，找到最长的递增序列
        //返回时，dp数组最后一个不一定是最大值
        int res = 1;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```

**2022/4/27二刷**

#### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

```c++
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 
```

子数组必须是连续的

`dp[i+1][j+1]`表示以`nums1[i]` 和` nums2[j]`结尾的两个数组的最长重复子数组

|      |      | 1    | 2    | 3    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      | 0    | 1    | 2    | 3    | 4    |
| 3    | 0    | 0    | 0    | 1    | 0    | 0    |
| 2    | 1    | 0    | 1    | 0    | 2    | 0    |
| 1    | 2    | 1    | 0    | 0    | 0    | 3    |
| 4    | 3    | 0    | 0    | 0    | 0    | 0    |
| 7    | 4    | 0    | 0    | 0    | 0    | 0    |

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (nums1[i] == nums2[j]) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                    res = max(res, dp[i + 1][j + 1]);
                }
            }
        }
        return res;
    }
};
```

#### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

##### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

##### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

```c
输入：text1 = "abcde", text2 = "ace" 
输出：3 
```

子序列可以不连续

`dp[i+1][j+1]`表示以`text1[i]` 和` text2[j]`结尾的两个字符串的最长公共子序列

|      |      |      | a    | b    | c    | d    | e    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | \    | 0    | 1    | 2    | 3    | 4    | 5    |
|      | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| a    | 1    | 0    | 1    | 1    | 1    | 1    | 1    |
| c    | 2    | 0    | 1    | 1    | 2    | 2    | 2    |
| e    | 3    | 0    | 1    | 1    | 2    | 2    | 3    |

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (text1[i] == text2[j]) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }
        return dp[m][n];
    }
};
```

#### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

```c++
输入：s = "babgbag", t = "bag"
输出：5
```

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

思路：字符串 `t`是背包，字符串 `s`是物品，装满背包的方案数目

外层是背包，内层是物品

执行用时：16 ms, 在所有 C++ 提交中击败了93.49%的用户

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        if (s.size() == 0 || t.size() == 0) {
            return 0;
        }
        vector<vector<uint64_t>> dp(t.size() + 1, vector<uint64_t>(s.size() + 1, 0));
        for (int i = 0; i <= s.size(); i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i < t.size(); i++) {
            for (int j = i; j < s.size(); j++) {
                if (s[j] == t[i]) {
                    dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j];
                } else {
                    dp[i + 1][j + 1] = dp[i + 1][j];
                }
            }
        }
        return dp[t.size()][s.size()];
    }
};
```

**2022/4/6~2022/4/8**

#### [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` 相同所需的最小步数。

每步可以删除任意一个字符串中的一个字符。

```cpp
输入：word1 = "leetcode", word2 = "etco"
输出：4
```

执行用时：20 ms, 在所有 C++ 提交中击败了85.11%的用户

```cpp 
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        //dp[i + 1][j + 1]表示以word1[i]和word2[j]结尾的字符串，相同时所需的最小步数
        for (int i = 1; i <= word1.size(); i++) {
            dp[i][0] = i;
        }
        for (int j = 1; j <= word2.size(); j++) {
            dp[0][j] = j;
        }
        for (int i = 0; i < word1.size(); i++) {
            for (int j = 0; j < word2.size(); j++) {
                if (word2[j] == word1[i]) {
                    dp[i + 1][j + 1] = dp[i][j];
                } else {
                    dp[i + 1][j + 1] = min(dp[i + 1][j], dp[i][j + 1]) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

#### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

```cpp
输入：word1 = "intention", word2 = "execution"
输出：5
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        for (int i = 0; i <= n1; i++) dp[i][0] = i;
        for (int j = 0; j <= n2; j++) dp[0][j] = j;
        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = min(dp[i - 1][j- 1], min(dp[i - 1][j], dp[i][j - 1])) +1;
            }
        }
        return dp[n1][n2];
    }
};
```

#### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```cpp
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

```CPP
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        //dp[i][j]表示[i, j]区间的子串，是否是回文子串
        //递推公式：如果s[i]和s[j]相等，dp[i][j] = dp[i + 1][j + 1]
        //需要提前知道dp[i + 1][j + 1]的值，因此要从下往上遍历
        int res = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[j] == s[i]) {
                    if (j - i <= 1) {
                        res++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]){
                        res++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return res;
    }
};
```

#### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**回文子串要求是连续的，而回文子序列没有要求连续。**

```cpp
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

```CPP
//回溯法超时
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        //dp[i][j]表示字符串在[i, j]范围内最长的回文子序列
        int len = s.size();
        vector<vector<int>> dp(len, vector<int>(len, 0));
        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < len; j++) {
                if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2;
                else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        return dp[0][len - 1];
    }
};
```

**2022/4/28二刷**

将字符串反转，计算两个字符串的最长公共子序列即可。

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        string s1(s);
        reverse(s1.begin(), s1.end());
        
        vector<vector<int>> dp(s1.size() + 1, vector<int>(s.size() + 1, 0));
        
        for (int i = 1; i <= s1.size(); i++) {
            for (int j = 1; j <= s.size(); j++) {
                if (s[j - 1] == s1[i - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[s1.size()][s.size()];
    }
};
```

#### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

返回最长的回文子串

```c++
输入：s = "babad"
输出："bab"
```

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        int maxlen = 0;
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (i == j || i + 1 == j) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && j - i + 1 > maxlen) {
                    maxlen = j - i + 1;
                    res = s.substr(i, maxlen);
                }
            }
        }
        return res;c
    }
};
```

**总结：子串与子序列做法完全不同，子串必须连续；子序列可以不连续**

**2022/5/7**

#### [10. 正则表达式匹配（重点题型）](https://leetcode.cn/problems/regular-expression-matching/)

正则表达式

`'.'`可匹配任意单个字符

`'*'`可匹配任意个前一位的元素（可以匹配0个【将当前位跳过】，无数个【将目标字符串加一】）

递归思路：

1. 当没有`'*'`时：判断当前元素是否相等或者当前为`'.'`
2. 当前的下一位是`'*'`：可以将当前的元素跳过（当前字符串长度加2，此时无需考虑目标字符串），或者判断当前元素是否相等，若相等则将目标字符串长度加1（匹配多个前面的那个元素）

【注意：匹配多个前一位的元素时，当前字符串是不加一的，只是将目标串加一，因为要判断目标出的下一位是否同样跟当前元素匹配比如 aaa 和 a*】

```c++
输入：s = "absfdfgdf", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

```cpp
// 递归回溯
class Solution {
public:
    bool recfunc(const string & s, const string & p, int i, int j) {
        if (j == p.size()) {
            return i == s.size();
        }

        bool first_match = (i < s.size() && (p[j] == s[i] || p[j] == '.')) ? true : false;
        if (j + 1 < p.size() && p[j + 1] == '*') {
            return recfunc(s, p, i, j + 2) || (first_match && recfunc(s, p, i + 1, j));
        } else {
            return first_match && recfunc(s, p, i + 1, j + 1);
        }
    }
    bool isMatch(string s, string p) {
        if (p.empty()) {
            return s.empty();
        }
        return recfunc(s, p, 0, 0);
    }
};
```

动态规划思路：

1. 若当前遍历元素是"*"：可跳过；或者判断前一个元素是否匹配，若匹配结果等于上一轮当前元素结果（匹配任意个*****前元素）
2. 不是“*”：正常判断是否匹配即可。

`dp[i][j]`：字符串s中的[0, i]子串与字符串p中的[0, j]子串是否正则匹配

初始化：遇到*可抵消

```cpp
// 动态规划
class Solution {
public:
    // 判断首元素是否相等
    bool first_match(const string & s, const string & p, int i, int j) {
        return s[i - 1] == p[j - 1] || p[j - 1] == '.';
    }
    bool isMatch(string s, string p) {
        int lens = s.size(), lenp = p.size();
        vector<vector<bool>> dp(lens + 1, vector<bool>(lenp + 1, false));
        // 初始化
        dp[0][0] = true;
        for (int j = 2; j <= p.size(); j++) {
            dp[0][j] = p[j - 1] == '*' && dp[0][j - 2];
        }
        for (int i = 1; i <= lens; i++) {
            for (int j = 1; j <= lenp; j++) {
                // 递推公式 存在“*”，当前字符串长度减掉2；或者若“*”前元素相等，目标字符串长度减掉1
                // 不存在“*”时，判断当前元素是否相等，若相等，则状态等于前一时刻的状态
                if (p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 2] || (first_match(s, p, i, j - 1) && dp[i - 1][j]);
                } else dp[i][j] = first_match(s, p, i, j) && dp[i - 1][j - 1];
            }
        }
        return dp[lens][lenp];
    }
};
```

总结：`“.*”`是无敌的，可匹配任意字符串。每一个回合都利用`’.‘`实现匹配任意个当前字符。

#### [32. 最长有效括（重点）](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        vector<int> dp(s.size(), 0);
        //dp[i]：以s[i]结尾的子串的最长有效长度
        int maxlen = 0;
        //i = 0不需要判断，只有一个组不成括号对
        for (int i = 1; i < s.size(); i++) {
            if (s[i] == '(') {
                continue;
            } else {
                //上一个是'('，当前的等于上上一个加2
                if (s[i - 1] == '(') {
                    dp[i] = 2;
                    //需要判断一下，否则数组访问越界
                    if (i - 2 >= 0) {
                        dp[i] += dp[i - 2];
                    }
                //上一个是')'，判断前边是否有有效的'('，此处是【重点】。利用上一个')'的有效距离计算出紧挨着的位置是否是'('
                } else if (dp[i - 1] > 0){
                    if (i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        //同样需要判断是否越界
                        if (i - dp[i - 1] - 2 >= 0) {
                            dp[i] += dp[i - dp[i - 1] - 2];
                        }
                    }
                }
            }
            maxlen = max(maxlen, dp[i]);
        }
        return maxlen;
    }
};
```

#### [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

能想到动态规划，但是递归公式没想出来，利用方块图求最大矩形面积，因方块图是可变的，不需要用传统方法

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '0') {
                    continue;
                }
                if (j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i][j - 1] + 1;
                }
                int row = i;
                int wed = dp[row][j];
                while (row >= 0 && dp[row][j]) {
                    wed = min(wed, dp[row][j]);
                    res = max(res, wed * (i - row + 1));
                    row--;
                }
            }
        }
        return res;
    }
};
```

#### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```c++
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**注意数组下标越界问题，特别是减一的情况，判断是否有效。标记处1.2.3.需注意~**

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int res = 0;
        int n = s.size();
        vector<int> dp(n, 0);
        //dp[i]以s[i]结尾的字符串的有效长度
        //1.'('：以'('结尾的不是有效字符，等于0
        //2.')'：从i - 1开始找到第一个没有被使用的'('，若前一位是')'且dp[]值为0，无效字符，跳过/若找到'('，长度为i - j + 1，还没完，加上前一段的长度，前提要判断是否坐标大于0
        for (int i = 1; i < n; i++) {
            if (s[i] == ')') {
                int j = i - 1;
                while(j >= 0 && s[j] == ')') {  //1.
                    if (dp[j] == 0) {
                        break;
                    }
                    j -= dp[j];
                }
                if (j >= 0 && s[j] == '(') {  //2.
                    dp[i] = i - j + 1;
                    if (j > 0) { //3.
                        dp[i] += dp[j - 1];
                    }
                    res = max(res, dp[i]);
                }
            }
        }
        return res;
    }
};
```



## 动态规划总结篇

动规的核心在于，当前时刻的值是根据前一时刻的值推导出来的

首先搞清楚dp的含义

递推数组的初始化

内外层的遍历顺序

几种典型题：

1. 列出每一个时刻的几种不同状态，比如买或者不卖、卖或者不卖，用或者不用记录等，利用动规记录每个情形能获得的最大值，下一时刻根据前一时刻推导。
2. 背包问题，组合排列问题装满背包多少种不同方案，商品可重复或不可重复；装满背包能得到的最大价值；用最少数量的物品装满背包等等。
3. 字符串问题，每一次的子序列结果都是根据前一时刻推导出来的。是否连续，是否可以重复。两个子序列的最长公共子序列；最长重复子数组；编辑距离问题；回文子串问题。

子串：连续

子序列：可以不连续

子数组：连续

