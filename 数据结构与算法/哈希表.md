# 哈希表 Hash_table

哈希表是根据关键码的值而直接进行访问的数据结构。

<img src="https://img-blog.csdnimg.cn/20210104234805168.png" style="zoom:67%;" />

**哈希表都是用来快速判断一个元素是否出现集合里。**

## 哈希函数

将value映射到哈希表上，key成为下标，可直接根据key索引。

当两个value的键值相同时，发生哈希碰撞，一般采用拉链法。

## 红黑树

1、二叉排序树

2、它满足如下几点要求： 树中所有节点非红即黑；根节点必为黑节点；红节点的子节点必为黑（黑节点子节点可为黑）；从根到NULL的任何路径上黑结点数相同。

3、查找时间一定可以控制在O(logn)。

## 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set (集合)
- map (映射)

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合          | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率    | 增删效率    |
| ------------- | -------- | -------- | ---------------- | ------------ | ----------- | ----------- |
| set           | 红黑树   | 有序     | 否               | 否           | $O(\log n)$ | $O(\log n)$ |
| multiset      | 红黑树   | 有序     | 是               | 否           | $O(\log n)$ | $O(\log n)$ |
| unordered_set | 哈希表   | 无序     | 否               | 否           | $O(1)$      | $O(1)$      |

set 的key与value相同，不可出现重复数值。

`unordered_set`底层实现为哈希表，`set `和`multiset `的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

当我们要使用集合来解决哈希问题的时候，优先使用**unordered_set**，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用`set`，如果要求不仅有序还要有重复数据的话，那么就用`multiset`。

| 映射          | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率    | 增删效率    |
| ------------- | -------- | -------- | ---------------- | ------------ | ----------- | ----------- |
| map           | 红黑树   | key有序  | key不可重复      | key不可修改  | $O(\log n)$ | $O(\log n)$ |
| multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | $O(\log n)$ | $O(\log n)$ |
| unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | $O(1)$      | $O(1)$      |

`unordered_map` 底层实现为哈希表，map 和multimap 的底层实现是红黑树。同理，map 和multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

map 是一个`<key,  value> `的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然set、multiset 的底层实现是红黑树，不是哈希表，但是set、multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set、hash_map，这个与unordered_set、unordered_map又有什么关系呢？

实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal()，可以重复插入；而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。

#### `unordered_map`不能直接排序，需要将键值对`pair`保存到`vector`中，然后自定义排序方式。

#### 一般结合find(key)函数使用，返回关键字key在映射中的位置。

如果要是`set`无所谓，`key = value`

如果要是`map`要注意，`key`存放的元素

`unordered_set`初始化：

```cpp
unordered_set<int> mset;
for (int i = 0; i < nums.size(); i++) mset.insert(nums[i]);

unordered_set<int> mset(nums.begin(), nums.end());
```

`unordered_map `初始化：

```c++
unordered_map<char, int> m;
m['a'] = 1;
m[' '] = 2;
m['A'] = 3;
cout << m.size() << endl;  //3
if (m.count(' ') == 1) cout << m[' '] << endl;  //2
m.insert(pair<char, int>('Z', 12));
```

#### 例程：力扣题202 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

分析：给定一个树，求每一位的平方和再对求平方和等于一为止。

**题目中将可能无线循环，也就是说求和过程中，sum值可能会重复出现。当我们要快速判断一个元素是否出现在集合中时，要选择哈希表。本题选择unordered_set，无序、不可以有重复数值数据结构。当判断一个元素已经在表中，说明已经循环了，即不是快乐数。**

代码：

```c++
   int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while (1) {
            int sum = getSum(n);
            if (sum == 1) return true;
            if (set.find(sum) != set.end()) return false;
            set.insert(sum);
            n = sum;
        }
    }
    //19是，2不是
```

#### 例程：力扣454 四数相加

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

分析：

利用哈希表，首先求出数组1和数组2的元素两数之和，key存放和，value存放和出现的次数。定义count变量存放四数之和出现的次数。再遍历数组3和数组4，查找 0 - (c + d)是否在map中，若出现将value次数累加到count。

代码：

```c++
int fourSumCount(vector<int>& nums1, vector<int>& nums2, 
                 vector<int>& nums3, vector<int>& nums4) 
{
        unordered_map<int, int> map;
        int count = 0;
        int n = nums1.size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                auto iter = map.find(nums1[i] + nums2[j]);
                if (iter != map.end()) {
                    iter->second++;
                }
                else {
                    map.insert(pair<int, int> (nums1[i] + nums2[j], 1));
                }
            }
        }
        for (int k = 0; k < n; k++) {
            for (int l = 0; l < n; l++) {
                auto iter = map.find(0 - nums3[k] - nums4[l]);
                if (iter != map.end()) {
                    count += iter->second;
                }
            }
        }
        return count;
}
```

总结：形如N个数相加等于target的题，一般计算长度的一半的值，在另一半中寻找`target - (...)`

#### 力扣347前K个高频元素

```c++
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**哈希表自定义排序**

### 哈希表不支持自定义排序，先将键值对放入vector中，利用vector自定义排序对键值对进行间接排序

```cpp
class Solution {
public:
    static bool mysort(const pair<int, int>& m1, const pair<int, int>& m2) {
        return m1.second > m2.second;
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> result;
        unordered_map<int, int> m;
        //哈希表O(1)，统计元素出现次数
        // for (int i = 0; i < nums.size(); i++) {
        //     if (m.find(nums[i]) != m.end()) m[nums[i]]++;
        //     else m[nums[i]] = 1;
        // }
        for (auto x : nums) m[x]++;
        
        //vector保存键值对，自定义降序排序
        vector<pair<int, int>> v;
        for (auto x : m) v.push_back(x);
        sort(v.begin(), v.end(), mysort);
        
        for (int i = 0; i < k; i++) {
            result.push_back(v[i].first);
        }
        return result;
    }
};
```

哈希表利用vector自定义排序功实现

```c++
vector<pair<char, int>> res(m.begin(), m.end());
sort(res.begin(), res.end(), [](auto &a, auto &b) {return a.second > b.second;});
```

### 哈希冲突解决办法？

#### 开放地址法

遇到哈希冲突时，去寻找一个新的空闲的哈希地址

##### 线性探测

向后依次寻找

##### 平方探测

公式：`h(x) = (Hash(x) + i)mod(Hashtable.length);``i`从0开始遍历，取值为`+(i^2),-(i^2)`

#### 再哈希法

同时构造多个哈希函数，当前哈希函数计算结果发生冲突，采用第二个、第三个……直到计算结果不冲突

#### 开链法

将所有哈希地址相同的都记录在同一个链表中

  





