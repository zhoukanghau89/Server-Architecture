# 二叉树

## 1.二叉树的理论基础

### 二叉树的种类

#### 满二叉树

如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

#### 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

![img](https://img-blog.csdnimg.cn/20200920221638903.png)

#### 二叉搜索树（二叉排序树）

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

#### 平衡二叉搜索树

又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![img](https://img-blog.csdnimg.cn/20200806190511967.png)

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，但是unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

### 存储方式

链式存储、顺序存储

链式存储方式用指针， 

顺序存储的方式是用数组。**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

### 遍历方式

深度优先遍历：前中后序遍历

广度优先遍历：层序遍历

### 二叉树定义

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 2.递归三要素

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

## 3.求二叉树的属性

**是否对称** 判断二叉树是否镜像对称

分析：判断二叉树是否镜像对称，就是判断两棵树的是否相等，一个树左右中，另一个右左中

1.确定递归函数的参数和返回值

```c++
bool compare(TreeNode* left, TreeNode* right)
```

2.终止条件

有一个为空 返回false

两个均为空 返回true

两个不为空 不相等 返回false

​                    相等 返回true

```c++
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false; // 注意这里我没有使用else
```

3.递归内容

```c++
bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
bool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）
return isSame;
```

**求最大深度、求最小深度**  层序遍历

## 4.二叉树的修改与构造 

**构造二叉树**    **根据中序与后序序列构造二叉树、根据前序与中序序列构造二叉树**

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

疑难点：切割区间，保持左闭右开；先切中序数组，左边为左子树、右边为右子树，再切后序数组，因为中序与后续数组的大小是相同的；另外在传参时，尽量用下标，减少用数组，可以减少对空间的使用。

#### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```c++
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //拆分，树中没有重复元素
        int len = postorder.size();
        if (len == 0) {
            return nullptr;
        }
        
        int root_val = postorder[len - 1];
        TreeNode * root = new TreeNode(root_val);
        if (len == 1) {
            return root;
        }

        int pos;
        for (int i = 0; i < len; i++) {
            if (inorder[i] == root_val) {
                pos = i;
                break;
            }
        }
        if (pos > 0) {
            vector<int> inorder_l(inorder.begin(), inorder.begin() + pos);
            vector<int> postorder_l(postorder.begin(), postorder.begin() + pos);
            root->left = buildTree(inorder_l, postorder_l);
        }
        if (pos + 1 < len) {
            vector<int> inorder_r(inorder.begin() + pos + 1, inorder.end());
            vector<int> postorder_r(postorder.begin() + pos, postorder.begin() + pos + inorder_r.size());
            root->right = buildTree(inorder_r, postorder_r);
        }
        return root;
    }
};
```

**翻转二叉树**

**合并二叉树**

## 5.二叉搜索树

注意是有序数组

#### 114. 二叉树展开为链表

```cpp
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220506102051331.png" alt="image-20220506102051331" style="zoom: 67%;" />

题目：将二叉树展开为一个单链表结构。每个节点左子树为空。使用前序遍历。

重点在于找到每个左子树的最后一个节点，作为右子树的父节点。

先判断左子树。

```cpp
class Solution {
public:
    TreeNode * preOrder(TreeNode * root) {
        if (!root) return nullptr;
        if (root->left) {
            TreeNode * tmp = root->right;
            TreeNode * nleft = preOrder(root->left);
            root->right = root->left;
            root->left = nullptr;
            if (tmp) {
                nleft->right = tmp;
                return preOrder(tmp);
            }
            else return nleft;
        }
        else if (root->right) {
            return preOrder(root->right);
        }
        return root;
    }
    void flatten(TreeNode* root) {
        preOrder(root);
    }
};
```

#### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

**【根据上一个节点与当前节点的值来判定类 题目】**

##### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

##### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

找到出现频率最高的元素，比如频率最高是2，找出所有出现两次的元素

定义一个前向节点

```c++
TreeNode * pre = nullptr;
```

首先判断当前几点是否与前向节点值相等，相等就把当前出现频率加一

再判断出现频率，当前频率等于最高频率，加入数组；当前频率大于最高频率，清空数组加入当前元素

```c++
class Solution {
private:
    vector<int> res;
    int cur = 0;
    int max = 0;
    TreeNode * pre = nullptr;
public:
    void findModeFunc(TreeNode * root) {
        if (root == nullptr) {
            return;
        }
        findModeFunc(root->left);
        if (pre && pre->val == root->val) {
            cur++;
        } else {
            cur = 1;
        }
        if (cur == max) {
            res.push_back(root->val);
        } else if (cur > max){
            max = cur;
            res.clear();
            res.push_back(root->val);
        }
        pre = root;
        findModeFunc(root->right);
    }
    vector<int> findMode(TreeNode* root) {
        findModeFunc(root);
        return res;
    }
};
```

#### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```c++
class Solution {
private:
    vector<int> isfind{false, false};
    TreeNode * result = NULL;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL) {
            return NULL;
        }
        TreeNode * p1 = lowestCommonAncestor(root->left, p, q);
        if (result) {
            return result;
        }
        TreeNode * p2 = lowestCommonAncestor(root->right, p, q);
        if (result) {
            return result;
        }
        //左右子树各有一个，找到祖先
        if (p1 && p2) {
            result = root;
            return result;
        }
        //左右子树找到一个且当前节点是另一个，找到祖先
        if ((root == p || root == q) && (p1 || p2)) {
            result = root;
            return result;
        }
        //左右子树没找到，仅找到当前节点/或者当前节点不是，左右子树仅找到一个
        if (root == p) {
            isfind[0] = true;
            return root;
        } else if (root == q) {
            isfind[1] = true;
            return root;
        } else if (p1 || p2) {
            return root;
        }
        return NULL;
    }
};
```

## 6.二叉树与动态规划

#### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

从树中的任意节点出发，沿任意路径，不可重复经过某一节点，求最大的路径和。

从下往上走，每走一步更新一下，每一步判断左-中-右这个特殊路径的值

```c++
class Solution {
private:
    int maxpath;
public:
    int backtracking(TreeNode * root) {
        if (root == nullptr) {
            return INT_MIN;
        } 
        int res = root->val;
        int left = backtracking(root->left);
        int right = backtracking(root->right);
        maxpath = max(maxpath, max(left, right));  //保证树中的每个节点都能判断到

        // 大于0 就返回，否则丢弃
        if (left > 0 && right > 0) {
            maxpath = max(maxpath, res + left + right);
            res += max(left, right);
        } else if (left > 0) {
            res += left;
        } else if (right > 0) {
            res += right;
        }
        return res;
    }
    int maxPathSum(TreeNode* root) {
        maxpath = INT_MIN;
        maxpath = max(maxpath, backtracking(root));
        return maxpath;
    }
};
```

