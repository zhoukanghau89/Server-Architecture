# 线程 thread

允许应用程序并发执行多个任务

一个进程可以包含多个线程，同一个程序中所有线程会独立执行相同程序

进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。

查看指定进程的LWP 号码：`ps -Lf pid`

进程、线程区别：

1. 进程间信息难以共享。除去只读代码段，父子进程并未共享内存，必须采用进程间通信方式。
2. 调用fork()创建子进程代价过高。需要复制内存表、文件描述符表之类的进程属性，时间开销较大
3. 线程之间方便、快速地共享信息。仅需将数据复制到共享变量（全局或堆）即可
4. 创建线程通常比创建进程快10倍。线程间采用共享虚拟地址空间。

线程之间共享的资源：

进程ID、父进程ID， 进程组ID、会话ID， 用户ID、用户组ID， 文件描述符表， 信号处置

文件系统的相关信息：文件权限掩码、当前工作目录， 虚拟地址空间（除栈、.text）

非共享资源：

线程ID， 信号掩码， 线程特有数据， error变量， 实时调度策略和优先级， 栈、本地变量、函数调用链接

#### 线程创建

```c
/*
    #include <pthread.h>
    
    man函数所在线程成为主线程，其余称为子线程
    程序默认只有一个进程，fork函数可创建进程
    一个线程，pthread_create可创建线程
    
    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                    void *(*start_routine) (void *), void *arg);
    功能：创建一个子线程
    参数：
        thread：传出参数，线程创建成功后，保存线程ID
        attr：设置线程的属性，默认值NULL
        start_routine：函数指针，子线程需要处理的函数代码
        arg：向第三个参数传参
    返回值：成功为0
           失败返回错误号errnum（与errno不同）,获取错误号信息：strerror(int errnum);  //#include <string.h>
    编译：Compile and link with -pthread.
*/
#include<stdio.h>
#include<pthread.h>
#include<string.h>
void* callback(void* arg) {
    printf("child thread...\n");
    printf("arg val : %d\n", *(int*)arg);
    return NULL;
}
int main() {
    pthread_t tid;
    int val = 520;
    int ret = pthread_create(&tid, NULL, callback, (void*)&val) ;
    if (ret) {  //返回值不为0，失败
        char* errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }
    printf("main thread...\n");
    sleep(1);    //延迟1秒，等待子线程运行
    return 0;
}
```

```c
[root@localhost thread]# ./pthread_create
main thread...
child thread...
arg val : 520
```

#### 终止进程

若不在主程序运行结束前，将主线程退出，运行到`return 0;`时，子线程也会结束

```c
/*    
    #include <pthread.h>
    void pthread_exit(void *retval);
    功能：终止一个线程
    参数：retval，传递一个指针，作为一个返回值，可以在pthread_join()中
    pthread_self()：获取当前子进程的ID号
*/
#include<stdio.h>
#include<pthread.h>
#include<string.h>
void* callback(void* arg) {
    printf("child thread...\n");
    printf("child thread ID = %d\n", pthread_self());
    printf("arg val : %d\n", *(int*)arg);
    sleep(2);
    return NULL;  //相当于pthread_exit(NULL);
}
int main() {
    pthread_t tid;
    int val = 520;
    int ret = pthread_create(&tid, NULL, callback, (void*)&val);
    if (ret) {
        char* errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }
    printf("main thread...\n");
    printf("main thread ID = %d\n", pthread_self());
    printf("child thread ID = %d\n", tid);
    
    //主线程退出，不会影响其他子进程,退出后，主线程后续代码不会运行
    //若不在主程序运行结束前，将主线程退出，运行到return 0;时，子线程也会结束
    pthread_exit(NULL);
    sleep(1);
    return 0;
}
```

```c
[root@localhost thread]# ./pthread_exit
main thread...
main thread ID = 1285723968
child thread ID = 1277376256
child thread...
child thread ID = 1277376256
arg val : 520
//延迟2秒终止
```

#### 回收子线程

```c
/*    
    #include <pthread.h>
    int pthread_join(pthread_t thread, void **retval);
    功能：与已终止的线程进行连接
         回收子线程的资源
         阻塞函数，调用一次只能回收一个子线程
         一般在主线程使用
    参数：thread子线程ID
          retval：接受子线程退出时的返回值，一般为NULL
    返回值：成功为0，失败返回错误号
*/
#include<stdio.h>
#include<pthread.h>
#include<string.h>
void* callback(void* arg) {
    printf("child thread...\n");
    printf("child thread ID = %d\n", pthread_self());
    printf("arg val : %d\n", *(int*)arg);
    sleep(2);
    return NULL;
}
int main() {
    pthread_t tid;
    int val = 520;
    int ret = pthread_create(&tid, NULL, callback, (void*)&val);
    if (ret) {
        char* errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }
    printf("main thread...\n");
    printf("main thread ID = %d\n", pthread_self());
    printf("child thread ID = %d\n", tid);
    
    //主线程调用pthread_join回收子线程的资源
    ret = pthread_join(tid, NULL);
    if (ret) {
        char* errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }
    printf("子资源回收成功, ret : %d\n", ret);
    
    //主线程退出，不会影响其他子进程，退出后，主线程后续代码不会运行
    pthread_exit(NULL);
    sleep(1);
    return 0;
}
```

```c
[root@localhost thread]# ./pthread_join
main thread...
main thread ID = 460793664
child thread ID = 452445952
child thread...
child thread ID = 452445952
arg val : 520
子资源回收成功, ret : 0
```

#### 线程分离

```c
/*
    #include <pthread.h>
    int pthread_detach(pthread_t thread);
    功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。
         与回收资源类似，不需要手动回收子线程的资源
    注意：不能多次分离
*/
#include<stdio.h>
#include<pthread.h>
#include<string.h>
void* callback(void* arg) {
    printf("child pthread succ...\n");
    printf("child pthread ID : %ld\n", pthread_self());
    sleep(2);
    return NULL;
}
int main() {
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, callback, NULL);
    if (ret) {
        char* errorstr = strerror(ret);
        printf("pthread_create error : %s\n", errorstr);
    }
    printf("main pthread succ...\n");
    printf("main thread ID : %ld, child thread ID : %ld\n", pthread_self(), tid);

    //设置子线程分离
    ret = pthread_detach(tid);
    if (ret) {
        char* errorstr = strerror(ret);
        printf("pthread_create error : %s\n", errorstr);
    }
    printf("子线程分离成功 ret = %d\n", ret);
    
    pthread_exit(NULL);
    return 0;
}
```

```
[root@localhost thread]# ./pthread_detach
main pthread succ...
main thread ID : 140012430595904, child thread ID : 140012422248192
子线程分离成功 ret = 0
child pthread succ...
child pthread ID : 140012422248192
```

#### 线程取消

```c
/*
    #include <pthread.h>
    int pthread_cancel(pthread_t thread);
    功能：取消某个线程，并不会立马终止某个线程，运行到取消点时，线程终止

*/
#include<stdio.h>
#include<pthread.h>
#include<string.h>
void* callback(void* arg) {
    printf("child thread...\n");
    printf("child thread ID = %d\n", pthread_self());
    printf("arg val : %d\n", *(int*)arg);
    sleep(2);
    return NULL;
}
int main() {
    pthread_t tid;
    int val = 520;
    int ret = pthread_create(&tid, NULL, callback, (void*)&val);
    if (ret) {
        char* errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }
    printf("main thread...\n");
    printf("main thread ID = %d\n", pthread_self());
    printf("child thread ID = %d\n", tid);
    
    //取消线程
    ret = pthread_cancel(tid);
    if (ret) {
        char* errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }

    //主线程退出，不会影响其他子进程，退出后，主线程后续代码不会运行
    pthread_exit(NULL);
    sleep(1);
    return 0;
}
```

```
[root@localhost thread]# ./pthread_cancel
main thread...
main thread ID = 638379840
child thread ID = 630032128
child thread...
//子线程遇到printf取消点，结束
```

#### 线程属性

```c
/*
    int pthread_attr_init(othread_attr_t* attr);
        初始化线程属性
    int pthread_atrr_destroy()
        销毁
    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
    int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);
        设置线程分离的状态属性
*/

#include<stdio.h>
#include<pthread.h>
#include<string.h>

void* callback(void* arg) {
    printf("child pthread succ...\n");
    printf("child pthread ID : %ld\n", pthread_self());
    sleep(2);
    return NULL;
}
int main() {
    //创建一个线程属性变量
    pthread_attr_t attr;
    //初始化
    pthread_attr_init(&attr);

    //设置属性
    //设置线程分离
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    
    //获取线程栈的大小
    size_t stacksize;
    pthread_attr_setstacksize(&attr, stacksize);
    printf("线程栈的大小：%d\n", stacksize);

    pthread_t tid;
    int ret = pthread_create(&tid, &attr, callback, NULL);
    if (ret) {
        char* errorstr = strerror(ret);
        printf("pthread_create error : %s\n", errorstr);
    }
    printf("main pthread succ...\n");
    printf("main thread ID : %ld, child thread ID : %ld\n", pthread_self(), tid);

    ret = pthread_attr_destroy(&attr);
    if (ret) {
        char* errorstr = strerror(ret);
        printf("pthread_create error : %s\n", errorstr);
    }
    printf("线程属性设置成功\n");

    pthread_exit(NULL);
    return 0;
}
```

```
[root@localhost thread]# ./pthread_attr
线程栈的大小：4196416
main pthread succ...
main thread ID : 140629561263936, child thread ID : 140629552914240
线程属性设置成功
child pthread succ...
child pthread ID : 140629552914240
```

#### 线程同步

互斥量`1mutex (mtual excelusion)`

避免线程共享变量时出现问题，确保同时仅有一个线程可以访问共享资源。

<img src="C:\Users\zhouk\AppData\Roaming\Typora\typora-user-images\image-20220412105318893.png" alt="image-20220412105318893" style="zoom: 67%;" />

```c
/*
    int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                        const pthread_mutexattr_t *restrict attr);
        初始化互斥量
        参数：互斥量，互斥量属性
              restrict：C语言修饰符，被修饰的指针不能由另外的一个指针进行操作
        返回值 成功为0
    int pthread_mutex_destroy(pthread_mutex_t *mutex);
        释放互斥量资源
    int pthread_mutex_lock(pthread_mutex_t *mutex);
        加锁，阻塞线程。若有一个线程加锁，其余线程只能阻塞等待
    int pthread_mutex_lock(pthread_mutex_t *mutex);
        尝试加锁，若加锁失败，不会阻塞，直接返回
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
        解锁
*/

#include<stdio.h>
#include<pthread.h>
#include<string.h>
#include<unistd.h>

int tickets = 10;
pthread_mutex_t mutex;

void* sellticket(void* arg) {
    //卖票
    while (1) {
        pthread_mutex_lock(&mutex);
        if (tickets) {
            sleep(1);
            printf("%ld machine is selling the num of %d tickets.\n", pthread_self(), tickets);
            tickets--;
        }else {
            pthread_mutex_unlock(&mutex);
            break;
        }
        pthread_mutex_unlock(&mutex);
    }
    
    return NULL;
}
int main() {
    //初始化互斥量
    pthread_mutex_init(&mutex, NULL);

    //创建三个子线程
    pthread_t tid1, tid2, tid3;
    pthread_create(&tid1, NULL, sellticket, NULL);
    pthread_create(&tid2, NULL, sellticket, NULL);
    pthread_create(&tid3, NULL, sellticket, NULL);

    //回收线程资源，设置线程
    pthread_detach(tid1);
    pthread_detach(tid2);
    pthread_detach(tid3);

    //主线程退出
    pthread_exit(NULL);
    
    pthread_mutex_destroy(&mutex);
    return 0;
}

```

#### 死锁

死锁的几种场景：

1. 忘记释放锁
2. 重复加锁
3. 多线程多锁，抢占资源

#### 读写锁

1. 若有线程读数据，则其他线程允许执行读操作，但不允许写数据
2. 若有线程写数据，则其他线程都不允许读、写操作
3. 写是独占的，优先级更高

```c
/*
    案例：创建八个线程操作同一个全局变量
    3个线程不定时写这个全局变量
    5个线程不定时读这个全局变量
*/

#include<unistd.h>
#include<stdio.h>
#include<pthread.h>
#include<string.h>

int num = 1;
pthread_mutex_t mutex;
pthread_rwlock_t rwlock;

void* writeNum(void* arg) {
    while (1)
    {
        pthread_rwlock_wrlock(&rwlock);
        num++;
        printf("++write, wid = %ld, num = %d\n", pthread_self(), num);
        pthread_rwlock_unlock(&rwlock);
        usleep(100);
    }
    return NULL;
}
void* readNum(void* arg) {
    while (1)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("==read rid = %ld, num = %d\n", pthread_self(), num);
        pthread_rwlock_unlock(&rwlock);
        usleep(100);
    }
    return NULL;
}

int main() {
    //pthread_mutex_init(&mutex, NULL);
    pthread_rwlock_init(&rwlock, NULL);

    pthread_t wid[3], rid[5];

    for (int i = 0; i < 3; i++)  pthread_create(&wid[i], NULL, writeNum, NULL);

    for (int i = 0; i < 5; i++)  pthread_create(&rid[i], NULL, readNum, NULL);

    for (int i = 0; i < 3; i++)  pthread_detach(wid[i]);

    for (int i = 0; i < 5; i++)  pthread_detach(rid[i]);
    
    pthread_exit(NULL);
    pthread_mutex_destroy(&mutex);
    return 0;

}
```

```
++write, wid = 140230086891264, num = 607
++write, wid = 140230095283968, num = 608
++write, wid = 140230078498560, num = 609
==read rid = 140230070105856, num = 609
==read rid = 140230036535040, num = 609
==read rid = 140230044927744, num = 609
==read rid = 140230053320448, num = 609
==read rid = 140230061713152, num = 609
++write, wid = 140230086891264, num = 610
++write, wid = 140230095283968, num = 611
++write, wid = 140230078498560, num = 612
==read rid = 140230070105856, num = 612
==read rid = 140230036535040, num = 612
==read rid = 140230044927744, num = 612
==read rid = 140230053320448, num = 612
```

加上读写锁后，效率明显提高，实现了有线程在写时，其他线程不可读写。有线程在读时，其他线程可任意读。

#### 生产者、消费者案例

#### 条件变量

```c
#include<stdio.h>
#include<pthread.h>
#include<string.h>
#include<error.h>
#include<unistd.h>

/*
	pthread_cond_wait(&cond, mutex);
		1，线程放在等待队列上，解锁
		2，等待 pthread_cond_signal 或者 pthread_cond_broadcast信号之后去竞争锁
		3，若竞争到互斥索则加锁
*/

struct ListNode
{
    int val;
    struct ListNode* next;
};

pthread_mutex_t mutex;
struct ListNode* head = NULL;

//创建条件变量
pthread_cond_t cond;

void* producer(void* arg) {
    //不断都创建新的节点添加到链表中
    while (1){
        //头插
        
        pthread_mutex_lock(&mutex);
        struct ListNode* pNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        pNode->next = head;
        head = pNode;
        pNode->val = rand() % 1000;
        printf("New Node : val = %d, tid = %ld\n", pNode->val, pthread_self());
        
        //只要生产了一件商品，就通知消费者消费
        pthread_cond_signal(&cond);
        
        pthread_mutex_unlock(&mutex);
        usleep(1000);
    }
    return NULL;
}

void* customer(void* arg) {
    while (1) {
        //头删
        
        pthread_mutex_lock(&mutex);
        if (!head) {
            //链表为空，等待生产者生产
            pthread_cond_wait(&cond, mutex);
            pthread_mutex_unlock(&mutex);
            break;
        }
        struct ListNode* tmp = head;
        head = head->next;
        printf("Del Node : val = %d, tid = %ld\n", tmp->val, pthread_self());
        free(tmp);
        pthread_mutex_unlock(&mutex);
        usleep(1000);
    }
    return NULL;
}

int main() {
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);
    
    pthread_t ptids[5], ctids[5];

    for (int i = 0; i < 5; i++) pthread_create(&ptids[i], NULL, producer, NULL);
    for (int i = 0; i < 5; i++) pthread_create(&ctids[i], NULL, customer, NULL);
    
    for (int i = 0; i < 5; i++) pthread_detach(ptids[i]);
    for (int i = 0; i < 5; i++) pthread_detach(ctids[i]);

    //线程分离处理后，直接把互斥量销毁了，需要加一个延迟
    while (1) sleep(100);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

    pthread_exit(NULL);
    
    
    return 0;
}
```

#### 信号量

```c
/*      
    #include <semaphore.h>

    int sem_init(sem_t *sem, int pshared, unsigned int value);
       初始化
       参数：信号量地址
           pshard：0:线程，非0:进程
           value：信号量的值
    int sem_wait(sem_t *sem);
       对信号量加锁，调用一次将信号量的值减一，若等于0，则阻塞
    int sem_post(sem_t *sem);
       对信号量解锁，调用一次将信号量的值加一
*/

#include<stdio.h>
#include<pthread.h>
#include<string.h>
#include<error.h>
#include<unistd.h>
#include<stdlib.h>
#include<semaphore.h>

struct ListNode
{
    int val;
    struct ListNode* next;
};
struct ListNode* head = NULL;

pthread_mutex_t mutex;

sem_t psem;
sem_t csem;

//生产者
void* producer(void* arg) {
    //不断都创建新的节点添加到链表中
    while (1){
        //头插
        sem_wait(&psem);
        pthread_mutex_lock(&mutex);
        struct ListNode* pNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        pNode->next = head;
        head = pNode;
        pNode->val = rand() % 1000;
        printf("New Node : val = %d, tid = %ld\n", pNode->val, pthread_self());
        
        pthread_mutex_unlock(&mutex);
        sem_post(&csem);
        usleep(1000);
    }
    return NULL;
}

//消费者
void* customer(void* arg) {
    while (1) {
        //头删
        sem_wait(&csem);
        pthread_mutex_lock(&mutex);
        
        struct ListNode* tmp = head;
        head = head->next;
        printf("Del Node : val = %d, tid = %ld\n", tmp->val, pthread_self());
        free(tmp);
        pthread_mutex_unlock(&mutex);
        sem_post(&psem);
        usleep(1000);
    }
    return NULL;
}

int main() {
    pthread_mutex_init(&mutex, NULL);
    //生产者初始化为8，不阻塞，必须先生产再消费。意思最多可以生产八件产品，每生产一件就通知一次消费者可以进行消费了。消费者初始化为0，阻塞，等待生产者生产。
    sem_init(&psem, 0, 8);
    sem_init(&csem, 0, 0);
    
    pthread_t ptids[5], ctids[5];

    for (int i = 0; i < 5; i++) pthread_create(&ptids[i], NULL, producer, NULL);
    for (int i = 0; i < 5; i++) pthread_create(&ctids[i], NULL, customer, NULL);
    
    for (int i = 0; i < 5; i++) pthread_detach(ptids[i]);
    for (int i = 0; i < 5; i++) pthread_detach(ctids[i]);

    //线程分离处理后，直接把互斥量销毁了，需要加一个延迟
    while (1) sleep(100);
    pthread_mutex_destroy(&mutex);

    pthread_exit(NULL);
    
    
    return 0;
}
```

