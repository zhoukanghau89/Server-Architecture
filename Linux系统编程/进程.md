# 进程

## 进程概念

概念：程序动态的执行一次的过程。

从操作系统的核心来看，进程是操作系统分配的内存、CPU时间片等资源的最小单位。每一个进程都有自己独立的地址空间与执行状态。

**进程数据结构，称作进程数据块PCB（是操作系统用来感知进程的重要数据结构）**

程序：代码段+数据段 

进程：代码段 + 数据段  + 堆栈段 + PCB

进程是动态的，程序是静态的

一个进程只能对应一个程序，一个程序可对应多个进程

#### 进程的地址空间分布

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220805160911180.png" alt="image-20220805160911180" style="zoom: 67%;" />

- 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长，是一块连续空间
- 堆区：动态申请内存用，堆从低地址向高地址增长
- BSS段：存放程序中未初始化的全局变量和静态变量
- 数据段：存放程序中已初始化的全局变量和静态变量
- 代码段：存放程序中代码（只读）

进程三种状态：就绪、运行、等待

进程PID（*Process Identification*），指进程标识符，操作系统每打开一个程序都会创建一个进程ID。只要运行一程序，系统会自动分配一个标识。是暂时唯一，进程中止后，这个号码就会被回收，可能被分配给另一个新进程。

PPID 父进程

进程控制块：PID、进程控制信息、资源信息、现场保护信息

0号进程——内核进程

1号进程——init进程 /usr/sbin/init，由0号进程创建的

2-131072——可用进程标识符

```c
[root@localhost IO]# cat /proc/sys/kernel/pid_max
131072
```

**进程终止时操作系统做以下工作**：

1. 关闭软中断（信号章节）
2. 回收资源
3. 写记账信息
4. 置该进程为僵死状态，直到父进程查询到，进程才最终销毁
5. 转调度程序，由进程调度分配CPU，进行其他程序

**终止进程的五种方法**：

1. main()函数返回
2. 调用exit、_exit
3. 调用abort，SIGABRT信号
4. 由信号终止，CTRL + C，向当前进程发送SIGINT信号。

关于进程的一些命令

```
ps -aux | grep process // 查看进程
ps -ef | grep process // 查看进程
ps -eo pid,ppid,sid,tty,pgrp,comm,stat,cmd | grep -E 'PID|webserver'  // 显示具体信息
```



#### fork()函数

copy on write 写实拷贝机制

创建子进程，继承父进程所有地址信息。只有PID不同

准确来说，在变量没有发生改变之前，子进程是没有拷贝父进程的地址信息，并没有自己的独立空间，当有变量发生更改时，不在共享同一个副本

```c
<sys/types.h> 
<unistd.h>
pid_t fork(void);  // pid_t 进程标识符类型
```

返回值：调用一次，返回两次

成功则有两个进程副本，子进程为0，父进程大于0，失败返回-1。

两个进程各自在自己的进程空间返回的

1. fork()调用之后，父子进程执行的代码完全相同，但相继运行，顺序未知
2. 父进程先退出，子进程未退出，变成**孤儿进程**。托孤给1号进程

```c
      printf("current process pid = %d\n",getpid());
      pid_t fd;
      fd = fork();
      if (fd == -1)  ERR_EXIT("fork error.");
      if (fd > 0)
            printf("this is father process. 
                   Father process pid = %d, child pid = %d\n", getpid(), fd);   
      if (fd == 0)
            printf("this s child process. 
                   Child process pid = %d, father pid = %d\n", getpid(), getppid());
      close(fd);

```

```c
[root@localhost IO]# ./06fork
current process pid = 120207
this is father process. Father process pid = 120207, child pid = 120208
this s child process. Child process pid = 120208, father pid = 1
```

3. 子进程先推出，父进程还未查询到子进程退出，此时子进程处于**僵尸状态**

僵尸进程：已经被终止，不干活，但依旧没有被内核丢弃掉， 内核认为父进程仍可能需要子进程，需要手动处理掉，防止占用系统资源

1. 系统状态signal可避免僵尸进程，当子进程退出时，会向父进程发送一个SIGCHLD信号，父进程可将其忽略
2. 调用wait/waitpid函数

```C
ps -ef
root     120848   3928  0 21:34 pts/0    00:00:00 ./06fork
root     120849 120848  0 21:34 pts/0    00:00:00 [06fork] <defunct>
signal(SIGCHLD, SIG_IGN);
```

fork后，父子进程共享同一个文件表项

例程：向文件写入内容，更改gval的值

```c
int gval = 100;
int main(int argc, char *argv[])
{
        signal(SIGCHLD, SIG_IGN);
        printf("current pid = %d\n", getpid());
        int fd = open("test.txt", O_WRONLY);
        if (fd == -1)  ERR_EXIT("open error");
        
        pid_t pid;
        pid = fork();
        if (pid == -1) ERR_EXIT("fork error");
        if (pid > 0) {
             printf("parent pid = %d, child pid = %d, gval = %d\n", getpid(), pid, gval);
             write (fd, "1parent\n", 7);
        // sleep(100);
        }
        if (pid == 0) {
             gval++;
             printf("child pid = %d, parent pid = %d, gval = %d\n", getpid(), getppid(), gval);
             write (fd, "2child\n", 6);
        }
        close(pid);
        return 0;
}

[root@localhost PID]# ./06fork
current pid = 5786
parent pid = 5786, child pid = 5787, gval = 100
child pid = 5787, parent pid = 1, gval = 101
[root@localhost PID]# cat test.txt
1parent2child
```

例程：

```c
((fork() && fork()) || (fork() && fork()))  // 输出一共七个进程
// 第一个fork后两种情况 1.== 0 第二个fork被短路，直接判断3、4
//      1.1 第三个fork == 0，第四个被短路，此路结束
//      1.2 第三个fork > 0，第四个fork两种情况 == 0 或 > 0
// 2. > 0 判断第二个fork
// 2.1 第二个fork == 0，判断第三个fork，情况跟1，1一样
// 2.2 第二个fork > 0，后面连个fork被短路
```

#### vfork()函数

不进行拷贝父进程的地址空间，父子进程共享同一块地址空间

直到加载exec程序之前

例程：该更gval的值

```c
int gval = 100;
int main(int argc, char *argv[])
{
        signal(SIGCHLD, SIG_IGN);
        printf("current pid = %d\n", getpid());

        pid_t pid;
        pid = vfork();
        if (pid == -1) ERR_EXIT("vfork error");
        if (pid > 0) {
             printf("parent pid = %d, child pid = %d, gval = %d\n", getpid(), pid, gval);
        }
        else if (pid == 0) {
             gval++;
             printf("child pid = %d, parent pid = %d, gval = %d\n", getpid(), getppid(), gval);
             _exit(0);  //vfork()限制：子进程结束要立刻调用exec或者_exit，也可不带_
        }
        close(pid);
        return 0;
}
//不调用exit程序混乱
[root@localhost PID]# ./07vfork
current pid = 5981
child pid = 5982, parent pid = 5981, gval = 101
parent pid = 5981, child pid = 5982, gval = 101
current pid = 5981
child pid = 5983, parent pid = 5981, gval = 102
段错误
//调用exit函数
[root@localhost PID]# ./07vfork
current pid = 6069
child pid = 6070, parent pid = 6069, gval = 101
parent pid = 6069, child pid = 6070, gval = 101
```

vfork  保证子进程先运行，在调用exec 或exit 之前与父进程数据是共享的,在它调用exec或exit 之后父进程才可能被调度运行。

 fork   父子进程的执行次序不确定

exit与_exit区别

1. _exit系统调用，exit是C库函数
2. _exit直接调用内核，exit先清除缓冲区（缓冲区若不清理还残留的话，假如想输出到屏幕上是不能够显示）。  _exit不做缓冲区清理工作
3. exit会调用终止处理程序 
3. 使用值0或宏EXIT_SUCCESS来指示程序成功终止，使用宏EXIT_FAILURE指示程序非成功中止。

讲一下fork()函数一个小问题

当调用fork()函数时，为什么不是从程序的第一条语句开始执行，而是接着运行呢？

拷贝了   代码段 + 数据段  + 堆栈段 + PCB

两个进程的代码、数据、堆栈段完全一样，因为当前的运行环境已经保存在PCB中，并且将要执行的下一条地址也是一样的，因此不会从程序的第一条语句开始运行

##### execve函数

系统调用函数（替换进程映像）

#### SIGCHLD信号

当子进程退出，内核向父进程发送此信号，子进程的退出是个异步事件（子进程可在父进程运行的任何时刻退出）

退出后，内核将子进程设置为僵尸状态，这个进程为僵尸进程，只保留最小的内核数据结构，以便父进程查询子进程的退出状态。

查询命令： wait/waitpid函数（等待子进程退出的两个函数）

##### wait

不支持多个子进程

当fork调用时，wait函数随时等待子进程结束，如果父进程要结束会被挂起至子进程结束，并返回子进程的PID。

```c
int main(int argc, char *argv[])
{
        pid_t pid;
        pid = fork();
        if (pid == -1) ERR_EXIT("fork error");
        if (pid == 0) {
               sleep(3);
               printf("child process, pid = %d\n", getpid());
              //此处有个疑问，为社么此时子进程的pid = 0，而getpid = 22603？
             //pid不是子进程的进程号，是fork函数的返回值，调用成功子进程的返回值为0
               exit(100);
        }
        int ret;
        printf("parent process, pid = %d\n", getpid());
        int status;
        ret = wait(&status);
        printf("ret = %d, pid = %d\n", ret, pid);

        return 0;
}
[root@localhost PID]# ./08wait
parent process, pid = 22602
child process, pid = 22603
ret = 22603, pid = 22603
```

先执行父进程，再执行子进程，wait函数返回子进程的进程号22603

##### waitpid

等待特定的子进程

```c
#include <sys/types.h> 
#include <sys/wait.h> 
pid_t waitpid(pid_t pid,int *status,int options);
```

比wait多两个参数，pid与options

pid ：

1. pid > 0 等待pid 的子进程退出
2. pid = -1 等待任何子进程退出
3. pid = 0 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
4. pid < -1 等待abs(pid)的子进程退出

options可设置为0

#### 僵进程

子进程退出后，不会立刻释放，等待父进程结束或者父进程调用了wait函数

避免僵进程两种措施：

1. wait、waitpid
2. signal(SIGCHLD, SIG_IGN)  父进程忽略SIGCHLD信号，改信号是子进程退出时向父进程发送的

##### system

```c
int system(const char * command)
```

执行 dos(windows系统) 或 shell(Linux/Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。

说明：在windows系统中，system函数直接在控制台调用一个command命令。
在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。

系统命令，调用“/bin/sh -c command”执行特定命令，会阻塞当前进程直到command命令执行完毕。

```c
int my_system(const char* command) {
        pid_t pid;
        int status;
        if (command == NULL) {
               return 1;
        }
        pid =  fork();
        if (pid < 0)   status = -1;
        else if (pid == 0) {
              execl("/bin/sh", "sh", "-c", command, NULL);
              exit(127);
        }
        else {
               while (waitpid(pid, &status, 0)) {
                    if (errno == EINTR)   continue;
                    status = -1; break;
               }
        }
}
int main(int argc, char *argv[]) {
        system("ls -l | wc -w");   //统计当前目录下文件个数  //wc命令，统计文件中的行数
        return 0;
}
[root@localhost PID]# ./09sysctem
83
```

#### 守护进程

Linux后台服务的进程，脱离控制终端的孤儿进程，通常情况下系统启动时自动运行

查看守护进程

```c
[root@localhost PID]# ps axj
  PPID    PID   PGID    SID TTY  TPGID STAT UID  TIME COMMAND
     0      1      1      1 ?       -1 Ss     0  0:38 /usr/lib/systemd/systemd-- switched
     0      2      0      0 ?       -1 S      0  0:00 [kthreadd]
     2      3      0      0 ?       -1 S      0  0:04 [ksoftirqd/0]
     2      5      0      0 ?       -1 S<     0  0:00 [kworker/0:0H]
     2      7      0      0 ?       -1 S      0  0:00 [migration/0]
```

以超级用户 UID = 0 ， 没有控制终端 TTY = ？， 没有终端进程组 TPGID = -1

ppid = 0 是内核进程，跟随系统启动而启动，贯穿整个系统日常活动

创建守护进程

Linux 中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的 shell 登录终端。 控制终端、登录会话和进程组通常是从父进程继承下来的。目的就是要摆脱它们 ，使之不受它们的影响。因此需要调用 setsid() 使子进程成为新的会话组长。

setsid()函数调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。并且没有控制终端，因为会话过程对控制终端的独占性。

创建守护进程案例：

```c
int setup_daemon(void) {
    pid_t pid;
    pid = fork();   // 创建子进程
    if (pid < 0) {
        // 记录错误日志......
        return -1;
    } else if (pid > 0) {
        exit(EXIT_SUCCESS); // 关闭父进程
    }
       
    if (setsid() == -1) {
        // 建立新会话，将子进程设置为终端进程，子进程有单独的sid，成为一个新的会话组组长
        // 记录错误日志......
        return -1;
    }
    umask(0);  // 设置为0，不要让他来限制文件描述符，以免引起混乱
    int fd = open("/dev/null", O_RDWR); // 空设备，丢弃一切写入其中的设备（像黑洞一样）
    
    /*将输入输出重定向到黑洞，就是破坏掉输入输出，停止他的使用*/
    
    if (fd == -1) {
        // 记录错误日志......
        return -1;
    }
    if (dup2(fd, STDIN_FILENO) == -1) {
        // 先将输入关闭，将输入重定向到fd（黑洞）
        // 记录错误日志......
        return -1;
    }
    if (dup2(fd, STDOUT_FILENO) == -1) {
        // 先将输出关闭，将输出重定向到fd（黑洞）
        // 记录错误日志......
        return -1;
    }
    if (fd > STDERR_FILENO) {
        // fd = 3，大于STDERR_FILENO，将fd关闭，方便后续使用
        close(fd);
    }
    return 1;
}
int main(int argc, char *argv[])
{
    if (setup_daemon() == -1) {
        // 创建守护进程失败，记录错误日志......
        return 1;
    }
    for(;;);
    return 0;
}
```

运行并查看进程状态

```c
[root@bogon ~]# ps -ef | grep 10daemontest
root      87603      1 99 18:09 ?        00:00:46 ./10daemontest
root      87633  80712  0 18:10 pts/4    00:00:00 grep --color=auto 10daemontest
10daemontest
```

创建成功

守护进程不会接收到的内核信号：SIGHUP、SIGINT

这些信号可以作为用户其他用途
