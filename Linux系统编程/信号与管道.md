# 信号与管道

## 信号

##### 中断：中断是系统对于异步事件的响应。

##### 信号：软中断

进程之间的常用通信手段，用来通知某个进程发生的事情

#### 信号的种类

查看信号 

```shell
kill -signal_num pid
```

```
SIGHUP：1号信号，终端断开信号，这也可以用于重新启动进程，这对于内存泄漏的守护程序很有用。

SIGINT：2号信号，Interrupt from keyboard（键盘输入中断，ctrl + c ），action：term

SIGQUIT：3号信号，Quit from keyboard（键盘输入退出，ctrl+ | ），action：core，产生core dump文件

SIGABRT：6号信号，Abort signal from abort(3)（非正常终止，double free），action：core

SIGKILL：9号信号，Kill signal（杀死进程信号），action：term，该信号不能被阻塞、忽略、自定义处理

SIGSEGV：11号信号，Invalid memory reference（无效的内存引用，解引用空指针、内存越界访问），action：core

SIGPIPE：13号信号，Broken pipe: write to pipe with no readers（管道中止: 写入无人读取的管道，会导致管道破裂），action：term，客户端关闭套接字，服务器端向其写入数据，会收到一个RST segment信号，如果服务器再次调用write，此时产生SIGPIPE信号。如果不忽略次信号，将关闭进程

SIGCHLD：17号信号，Child stopped or terminated（子进程关闭时发送给父进程的信号，但该信号为忽略处理的）僵尸进程信号

SIGCONT：18号信号，将暂停的进程继续

SIGSTOP：19号信号，Stop process（停止进程），action：stop，停止后可用SIGCONT继续，但是后台运行，fg回到前台

SIGTSTP：20号信号，Stop typed at terminal（终端上发出的停止信号，ctrl + z），action：stop

具体的信号采取的动作和详细信息可查看：man 7 signal
```

1-31   非可靠信号，信号可能丢失

34-64   可靠信号， 信号不会丢失

#### 信号的产生

1. 内核

   硬件产生，通过中断按键产生的信号

   内存访问异常等

2. 软件产生

   调用系统函数向进程发信号

##### kill函数

```shell
kill -[信号ID] pid   // 向进程号为pid的进程发送信号为ID的信号
kill -9 1156        // 向1156进程发送9号信号（杀死进程）
```

#### 信号的注册

当进程收到可靠信号的注册时，将sig位图（信号集）中对应的比特位置1。

```c
sigset_t // 信号集数据类型
```

将该信号的sigqueue节点加入到sigqueue队列中。

#### 信号的注销

将信号的sigqueue节点从sigqueue队列中出队。

执行信号处理函数，执行完后，需要需要判断sigqueue队列中是否还有相同的sigqueue节点：

1. 若没用，将sig比特位置0
2. 否则不更改sig位图中的比特位。

当正在执行某个信号的信号处理函数时，此时再次有相同信号来临时，信号阻塞，排队，暂时不会处理。

#### 信号阻塞与未决

执行信号处理的动作叫做信号递达，信号从产生到递达之间的状态叫做信号未决。进程可以选择阻塞（block）某个信号。被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。

阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是、在递达之后可选的一种处理动作。

信号的阻塞，不会影响信号的注册，信号的阻塞指的是当准备处理信号时，会判断当前信号是否为阻塞，如果该信号为阻塞，则暂时不处理该信号。
内核当中除了sig位图还有block位图，block位图是定义在struct task_struct结构体当中的。将block位图中对应的信号比特位置为1，表示阻塞该信号。

一个进程对应一个信号集，用来屏蔽当前进程屏蔽（阻塞）了哪些信号，如果将某个信号的比特位置1，则表示屏蔽了这个信号，此时再来同类信号，会被屏蔽掉。

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
// 参数1：更改当前信号屏蔽字的方法
// SIG-BLOCK：该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。set包含希望阻塞的信号
// SIG_UNBLOCK：该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集补集的交集。set包含了我希望解除阻塞的信号
// SIG_SETMASK：该进程新的信号屏蔽字将被set指向的信号集的值代替
// 参数2：新的信号集
// 参数3：一般为NULL
```

功能描述：设定该进程对信号集内的信号的处理方式（阻塞或不阻塞）

例程：信号终端信号被全部杀死掉，kill -9，结束进程

```c
int main(int argc,char* argv[]) {

       sigset_t set;
       sigset_t oldset;
       sigfillset(&set);    //将所有信号比特位置1
       int fd = sigprocmask(SIG_BLOCK, &set, &oldset);  // 设置当前进程的信号屏蔽集为set集合，将当前信号集保存到oldset集合中（调用sigprocmask之前的进程信号集）
       if (fd == -1) ERR_EXIT("sigprocmask error");
       while (1) {sleep(1); }

       return 0;
}
[root@localhost signal]# ./02block
^C^C^C
^C
^C
^\
^Z
[root@localhost signal]# ps -ef | grep 02block
root      62686   4052  0 20:07 pts/1    00:00:00 ./02block
root      62819   3928  0 20:10 pts/0    00:00:00 grep --color=auto 02block
[root@localhost signal]# kill -9 62686
^Z已杀死
```

#### 信号的处理方式

1. 默认处理方式 

宏： SIG_DFL 在操作系统内核中已经定义好了

大多数信号的默认处理动作是杀死这个进程

```c
signal(SIGINT, SIG_DFL);
```

2. 忽略处理

宏：SIG_IGN 收到信号忽略处理(进程即使收到信号也不会做任何事情)

```c
signal(SIGINT, SIG_IGN);
```

3. 自定义处理方式

```c
sighandler_t signal(int signum, sighandler_t handler);
```

sighandler_t 函数指针

signum 待捕捉信号

handler 接受到指定信号时，转去执行的操作函数 

handler 有两个特殊值 

​               SIG_IGN 屏蔽该信号

​               SIG_DFL  恢复默认行为

信号处理函数尽量少调用**系统函数**，若一定要调用要确保是**可重入函数**

```
void handler(int sig) {
           printf("recv a sig = %d\n", sig);
}
int main(int argc,char* argv[]) {
          signal(SIGINT, handler);

          for(;;);    //死循环持续捕捉信号，CTRL+\结束
          return 0;
}
[root@localhost signal]# ./01signal
^Crecv a sig = 2
```

常用信号集操作函数

```c
int sigemptyset(sigset_t *set);：//将信号集中的所有信号全置为0

int sigfillset(sigset_t *set);   //将信号集中的所有信号全置为1

int sigaddset(sigset_t *set, int signum); //将信号集中的某个信号置为1

int sigdelset(sigset_t *set, int signum); //将信号集中的某个信号置为0

int sigismember(const sigset_t *set, int signum); //signum信号是否被置位
```

**例程：模拟信号从产生到递达的全部过程，SIGINT信号阻塞，SIGQUIT信号解除阻塞，完成递达。**

```c
void handler(int sig) {
        if (sig == SIGINT)    printf("recv fig  = %d\n", sig);
        else if (sig == SIGQUIT) {
               sigset_t uset;
               sigemptyset(&uset);
               sigaddset(&uset, SIGINT);
               sigprocmask(SIG_UNBLOCK, &uset, NULL);
        }
}
int main(int argc,char* argv[]) {
       sigset_t set1;
       sigset_t set2;
       sigemptyset(&set2);
       sigaddset(&set2, SIGINT);
       if (signal(SIGINT, handler) == SIG_ERR)    ERR_EXIT("signal error");
       if (signal(SIGQUIT, handler) == SIG_ERR)    ERR_EXIT("signal error");
       int fd = sigprocmask(SIG_BLOCK, &set2, NULL);
       if (fd == -1) ERR_EXIT("sigprocmask error");
       while (1) {
               sigpending(&set1);
               int i;
               for (i = 1; i < 64; i++) {
                     if (sigismember(&set1, i)) putchar('1');
                     else putchar('0');
               }
               printf("\n");
               sleep(2); 
       }
      
       return 0;
}
[root@localhost signal]# ./03status
000000000000000000000000000000000000000000000000000000000000000
^C010000000000000000000000000000000000000000000000000000000000000
010000000000000000000000000000000000000000000000000000000000000
^\recv fig  = 2
000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000
^C010000000000000000000000000000000000000000000000000000000000000
^\recv fig  = 2
000000000000000000000000000000000000000000000000000000000000000
^Z
[4]+  已停止               ./03status
```

#### sigaction函数

signal由于兼容性、可靠性等一些历史问题，实际项目中不被采用，sigaction信号处理方式，取代signal函数

信号处理函数使用注意事项：

1. 尽量使用简单的语句做简单的事情，尽量不要调用系统函数以免引起麻烦
2. 若必须调用系统函数，要保证系统函数是可重入的
3. 若调用函数会引起errno的值，事先备份errno的值，信号处理函数返回之前，将errno恢复

```c
struct sigavtion sa;
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
//signum：信号
//act：处理动作
//oldact：一般为NULL
```



#### sigqueue函数



#### strace 进程信号跟踪

strace是跟踪进程执行时的系统调用和所接收的信号（即它跟踪到一个进程产生的系统调用，包括参数、返回值、执行消耗的时间）

```c
strace -e trace=signal -p processID
```



## 管道

#### 创建

“|”  管道符号

传递两个进程间的数据。

本质：内核数据块

特点：半双工，只能单方向流动

​           只能用于具有共同祖先的进程间通信。通常，fork生成的父子间进程可用管道

创建匿名管道

```c++
int pipe2(int pipefd[2], int flags);  
//fd[0]表示读端  fd[1]表示写端 成功返回0，失败返回-1，保存在error中
```

 ls 将数据输出到标准输出设备。dup2将标准输出重定向到管道的写端，ls将数据写入到管道中。

wc 从标准输入设备获取数据。dup2将标准输入重定向到管道的读端，wc将从管道中获取数据。

例程：实现将ls 数据输出到管道中，用wc从管道中获取数据。

```c
int main(int argc,char* argv[]) {
    int pipefd[2];
    if (pipe(pipefd) == -1) ERR_EXIT("pipe error");

    pid_t pid;
    pid = fork();
    if (pid == -1)   ERR_EXIT("fork error");

    if (pid == 0) {
        dup2(pipefd[1], STDOUT_FILENO);  //将STDOUT_FILENO重定向为1
        close(pipefd[1]);   //不需要标准写操作
        close(pipefd[0]);   //不需要标准读操作
        execlp("ls", "ls", NULL);   //execlp()替换函数
        fprintf(stderr, "error execute ls\n");
        exit(EXIT_FAILURE);

     }
     dup2(pipefd[0], STDIN_FILENO);  //将STDIN_FILENO重定向为0
     close(pipefd[0]);
     close(pipefd[1]);
     execlp("wc", "wc", "-w", NULL);
     fprintf(stderr, "error execute wc\n");
     exit(EXIT_FAILURE);
     
     return 0;
}
[root@localhost signal]# ./04pipe
8
[root@localhost signal]# ls | wc -w
8
//与ls | wc -wj
```

#### 命名管道

管道仅能在具有共同祖先的进程间通信。

如果想在不想关的进程间通信，交换数据，可以使用`FIFO`做这项工作。

创建 `mkfifo`

```c
   #include <sys/types.h>
   #include <sys/stat.h>

   int mkfifo(const char *pathname, mode_t mode);   //创建  参数一 路径、参数二权限
```

 打开 `open`

命名管道的打开规则

1.若当前打开操作是为读而打开FIFO时，

非阻塞模式关闭：直到有相应进程为写而打开FIFO

非阻塞模式：立刻返回成功

2.若当前打开操作是为写而打开FIFO时，

非阻塞模式关闭：直到有相应进程为读而打开FIFO

非阻塞模式：立刻返回失败，错误码为ENXIO



例程：打开写操作的进程，当有为读操作的进程打开时，写操作不阻塞。

```c
//fifor.c
int main(int argc,char* argv[]) {
    mkfifo("p1", 0644);
    int fd = open("p1", O_RDONLY);
    if (fd == -1)   ERR_EXIT("open error");
    printf("open succ\n");


    return 0;
}
//fifow.c
int main(int argc,char* argv[]) {
    int fd = open("p1", O_WRONLY);
    if (fd == -1)   ERR_EXIT("open error");
    printf("open succ\n");


    return 0;
}
//运行
[root@localhost signal]# ./06fifow

[root@localhost signal]# ./06fifow
open succ
[root@localhost signal]# ./05fifor
open succ
```

例程： 非阻塞模式

```c
int main(int argc,char* argv[]) {
    mkfifo("p1", 0644);
    int fd = open("p1", O_RDONLY | O_NONBLOCK);
    if (fd == -1)   ERR_EXIT("open error");
    printf("open succ\n");


    return 0;
}
[root@localhost signal]# ./05fifor
open succ
    
int main(int argc,char* argv[]) {
    int fd = open("p1", O_WRONLY | O_NONBLOCK);
    if (fd == -1)   ERR_EXIT("open error");
    printf("open succ\n");


    return 0;
}
[root@localhost signal]# ./06fifow
open error: No such device or address
```

//写、创建、清空

例程：创建读写文件，通过命名管道实现文件拷贝

```c++
//FIFOw.c
int main(int argc,char* argv[]) {
    mkfifo("testpipe", 0644);
    int infd;
    infd = open("test.txt", O_RDONLY);
    if (infd == -1)   ERR_EXIT("open error");

    int outfd;
    outfd = open("testpipe", O_WRONLY);
    if (outfd == -1) ERR_EXIT("open error");

    char buf[1024];
    int n;
    while ((n  = read(infd, buf, 1024)) > 0) {
        write (outfd, buf, n);
    }
    close(infd);
    close(outfd);
    return 0;
}
//FIFOr.c
int main(int argc,char* argv[]) {
    int outfd;
    outfd = open("test1.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (outfd == -1)   ERR_EXIT("open error");

    int infd;
    infd = open("testpipe", O_RDONLY);
    if (infd == -1) ERR_EXIT("open error");

    char buf[1024];
    int n;
    while ((n  = read(infd, buf, 1024)) > 0) {
        write (outfd, buf, n);
    }
    close(infd);
    close(outfd);
    unlink("testpipe");   //关闭命名管道
    return 0;
}
//先运行写端，再运行读端
[root@localhost signal]# cat test.txt
111111111
2222222
aaaaaaaaaa

[root@localhost signal]# vim 07FIFOw.c
[root@localhost signal]# cat test1.txt
111111111
2222222
aaaaaaaaaa
//成功拷贝test.txt文件
```

