# 网络编程

### 网络通信

#### 封装、分用

应用程序在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层的协议都将在上层数据的基础上加上自己的头部信息，以实现该层的功能，这个过程称为封装。

应用层：                                                                             应用数据

传输层：                                              TCP/UDP报文头 |应用数据

网络层：                             IP报文头|TCP/UDP报文头 |应用数据

链路层：以太网帧报文头|IP报文头|TCP/UDP报文头 |应用数据

局域网内的主机如何通信？

- 首先DNS域名解析，得到目标主机的IP地址。

- 在ARP高速缓存中查看是否有目标主机的MAC地址。

  若没有，在局域网内发送ARP请求广播，局域网内的所有主机都会收到ARP请求，只有目的主机才会发送应答。

  将目的主机的IP地址与MAC地址保存到ARP缓存中，方便下次建立连接。

### socket编程

#### 字节序

数据的高低位：

0X12345678 16进制数，从左边到右边对应着数据的高位到低位。

大端字节序：存放时将高数据位存放在内存的低地址中

```
0x12 34 56 78
//假设内存增长方向 低 -> 高 12 34 56 78
```

小端字节序：存放时将高数据位存放在内存的高地址中

```
0x12 34 56 78
//假设内存增长方向 低 -> 高 78 56 34 12
```

例程：测试主机字节序

```cpp
int main()
{
    unsigned int x = 0x12345678;
    unsigned char *p = (unsigned char*) &x;  //char 1个字节
    printf("%0x %0x %0x %0x\n",p[0],p[1],p[2],p[3]);
    return 0;
}
t@localhost net-programming]# ./01byteorder
78 56 34 12
```

主机字节序：小端字节序

网络字节序：大端字节序

**网络通信时，需要将主机字节序转换成网络字节序，另一端根据自身需求将网络字节序转换主机字节序**

#### 字节序转换函数

```cpp
#include <stdio.h>
#include <arpa/inet.h>
/*
h-主机，n-网络，s-short，l-long

//IP
htonl() //本地到网络
ntonl() //网络到本地

//port
htons() //本地到网络
ntons() //网络到本地
 
*/

int main()
{
    unsigned long addr = inet_addr("192.168.245.128");
    printf("addr=%u\n",ntohl(addr));   //%u无符号
    
    struct in_addr ipaddr;
    ipaddr.s_addr = addr;
    printf("%s\n",inet_ntoa(ipaddr));
    return 0;
}
[root@localhost net-programming]# ./02addr
addr=3232298368
192.168.245.128
```

#### socket地址

就是一个结构体，封装IP、Port

查看地址命令 `man 7 ip`

`AF_INET` `TCP/IPv4`协议族

```c
struct sockaddr_in {
              sa_family_t sin_family;    /* 地址族: AF_INET */
              u_int16_t sin_port;        /* 按网络字节次序的端口 */
              struct in_addr sin_addr;   /* internet地址,32w */
              };

              /* Internet地址. */
              struct in_addr {
              u_int32_t s_addr;      /* 按网络字节次序的地址 */
};
/typedef unsigned int   u_int32_t
```

#### IP地址转换

```c
in_addr_t inet_addr(const char *cp);
//将点分十进制的IP地址转换成32位的网络字节序的整数
char *inet_ntoa(struct in_addr in);
//将网络字节序转换成字符串IP地址
```

```c
int inet_pton(int af, const char *src, void *dst);
//af 地址族 AF_INET
//src 点分十进制IP地址字符串
//dst 保存转换结果

const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
//size dst数组的大小
//返回值 dst
```

```c
int main()
{
    unsigned long addr = inet_addr("192.168.245.128");
    printf("addr=%u\n", ntohl(addr));
    
    struct in_addr ipaddr;
    ipaddr.s_addr = addr;
    printf("%s\n", inet_ntoa(ipaddr));

    char* buf = "192.168.245.1";
    unsigned int num;
    //将点分十进制的IP字符串转换成网络字节序的整数
    inet_pton(AF_INET, buf, &num);
    unsigned char* p = (unsigned char *)&num;
    printf("%d %d %d %d\n", p[0], p[1], p[2], p[3]);

    return 0;
}
```

```c
[root@localhost net-programming]# ./02addr
addr=3232298368
192.168.245.128
192 168 245 1
```

#### socket函数

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220421102634262.png" alt="image-20220421102634262" style="zoom: 67%;" />

```c
头文件 <arpa/inet.h>
1.1 创建套接字 socket函数
int socket(int protofamily, int type, int protocol);
第一个 协议族：AF_INET(IPV4)、AF_INET6(IPV6)、PF_UNIX(unix域)
第二个 socket类型：SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW
套接字类型：
流式套接字SOCk_STREAM（TCP）提供面向连接的、可靠的数据传输
数据报式套接字SOCK_DGRAM（UDP）提供无连接、不可靠传输服务
原始套接字 SOCK_RAM 提供一种跨越传输层，直接对IP层封装的
第三个 协议：IPPROTO_TCP、IPPTOTO_UDP，可设为0根据前边的参数使用对应的默认的协议
调用socket创建的套接字返回描述符存在于协议族中，没有具体的地址，要赋予地址的话，调用bind()函数
1.2 绑定端口地址 绑定一个本地地址到套接字 bind函数
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
第一个 套接字描述符
第二个 const struct sockaddr*类型指针，指向绑定给sockfd的协议地址，IPV4对应的是sockaddr_in，IPV6对应的是sockaddr_in6
第三个 地址长度
1.3 监听 listen
将套接字用于监听进入的的连接（被动套接字用于接受，主动套接字用于发起连接）
int listen(int sockfd,int backlog)
backlog为相应的socket可以排队的最大连接个数，单指已完成队列
[root@localhost ~]# cat /proc/sys/net/core/somaxconn
128
listen将socket变为被动连接的，等待客户连接
1.4 接受 accept
功能：从已完成队列返回第一个连接，并创建新的套接字，通过新套接字（主动套字）与客户端通信；如果已完成连接队列为空，则阻塞等待。
默认为阻塞，直到有连接请求过来。
int accept(int sockfd,struct sockaddr *addr, socklen_t *addrlen,int flags);
addr、flags为对等方的套接字地址与对等方的地址长度
返回值：成功为新的用于通信的文件描述符
注：定义对等方的地址时，一定要给地址长度设置初值
1.5 连接 connect
连接远端服务器，仅适用于客户端 
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
sockfd：通信的文件描述符
addr：服务器地址信息
1.6 通信 
TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。
服务器端两种套接字，监听套接字、已连接套接字；客户端只有已连接套接字
memset(void *buffer, int c, int count);将buffer指向长度为count的数组置为0，用于初始花数组，清空数组。
```

#### TCP三次握手

三次握手根据TCP头部进行交互

TCP头部

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630214324507.png" alt="image-20220630214324507" style="zoom: 80%;" />

SYN同步序列编号、ACK确认号、FIN结束号、RST重置位

TCP三次握手发生在客户端连接时，客户端调用`connect`时

思想：“让我知道你已经知道”。交互双方都需要确保自己能接收发送数据。

![](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220421151027979.png)

```c
初始状态：客户端处于关闭状态，服务器端处于监听状态，客户端执行connect时，触发三次握手
第一次握手：
1.客户端将SYN标志位置为1
2.生成一个32位的随机序号seq=J ， 这个序号后边是可以携带数据（数据的大小）
第二次握手：
1.服务器端接收客户端的连接： ACK=1
2.服务器会回发一个应答号： ack=客户端的序号 + 数据长度 + SYN/FIN(按一个字节算)
3.服务器端会向客户端发起连接请求： SYN=1
4.服务器会生成一个随机序号：seq = K
第三次握手：
1.客户单应答服务器的连接请求：ACK=1
2.客户端回复收到了服务器端的数据：ack=服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)
双方建立TCP连接后，均为ESTABLISHED（已连接状态）
```

监听套接字队列：未完成连接队列，已完成连接队列

若当前已完成连接队列的排队数达到backlog，此时再有客户发送SYN请求，服务器将会忽略这个请求，不予回应。

因此若保证服务器尽可能多地处理客户请求，应尽快用accept把已完成队列中的连接取走

**三次握手详谈**

服务器调用listen监听端口等待客户端发起连接，当客户端调用connect向服务器发送一个数据包，并阻塞在这里等待服务器的应答包。服务器收到客户端发来的数据包后，将客户端的第一次握手放在监听套接字的未完成连接队列中，此时这个连接状态从LISTEN状态变成SYN_RCVD状态，服务器向客户端回应一个应答包，服务器调用accept并阻塞在这里等待客户端的应答包。客户端收到应答包后，连接状态从SYN_SENT状态变成ESTABLISHED状态，此时connect函数返回，向服务器发送一个应答包建立第三次连接。服务器收到客户端的应答包后，连接状态从SYN_RCVD变成ESTABLISHED状态，此时服务器将当前TCP连接加入到已完成连接队列中。accept函数将已完成队列的头部取出来返回给进程，并返回一个新的套接字。

**区分两个套接字**

监听套接字，只用来监听服务器的80端口，监听是否有客户端向服务器发起连接

已连接套接字，也叫通信套接字，用来保持客户端与服务器之间的通信，数据收发功能

**为什么需要三次握手？**

1. 确认双方的接收能力与发送能力均正常，并同步双方的序列号与确认号

2. 避免伪造数据包对服务器的攻击

服务器必须收到ack回应包才确信客户端是真实存在的，否则当前连接会一直放在未完成队列中，这个过程一般持续75ms，如果客户端一直不发送第三次握手连接，服务器会将当前连接从未完成队列中清除掉。

3. syn攻击
4. 避免浪费资源。若两次握手，服务器无法判断客户端是否接收到自己的确认信号，因此每收到一个连接请求就主动建立连接，造成资源浪费；当消息滞留时，服务器重复收到无用的连接请求，造成重复分配资源。

**三次握手可以携带数据吗？**

只有第三次可以。前两次防止恶意攻击，发送大量无用数据，造成对方花费时间，内存空间来接收这些报文。

**SYN攻击**

服务器的资源分配是在第二次握手时分配的，客户端是在第三次握手时分配。当客户端在短时间内伪造大量不存在的IP地址时，并向服务器不断地发送SYN包。服务器则回复确认包，并等待客户端确认，由于源地址不存在，因此服务器需要不断地发送直至超时，这些伪造的数据包占用未连接队列，导致正常的SYN请求因队列满了而被丢弃，从而导致网络拥塞甚至系统瘫痪。

如何预防？

- 缩短超时时间【SYN Timeout】
- 增加未连接队列数
- 过滤网关防护
- SYN cookies技术

#### TCP 四次挥手

发生在断开连接时，谁先调用`close`谁发起四次挥手请求。

![image-20220421151132892](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220421151132892.png)

释放过程：客户端发起关闭连接的请求，服务器可能数据没有传送完毕，收到客户端请求后首先发送一个ACK告诉客户端我收到你的请求了，但我还有工作要做，等服务器数据传输完毕给客户端发送FIN信号，此时服务器等待客户端的回信。让服务器知道客户端已经知道了，因此客户端收到后再次给服务器端发送一个回信，服务器收到后完成关闭连接。为了防止回信丢失，客户端再等2MSL个时间再关闭。

**MSL**，maximum srgment lifetime，报文最大生存时间，任何报文被丢弃前在网络上的最长时间。

**主动断开**的一方，会进入到**TIME_WAIT**状态，应尽量避免服务器出现此状态，一般持续一分钟左右，这个时间内，这个端口是不允许被使用的。

**为什么要引入TIME_WAIT状态？**

假设主动断开的一方为客户端。若客户端最后发送的Ack应答包丢失，那么服务器端会重新发送FIN，这样因为客户端有TIME_WAIT的存在，会重新向服务器端发送Ack应答包。但是如果没有TIME_WAIT这个给状态，客户端发送完Ack应答包后就会关闭，若Ack丢失，服务器会重新发送一个FIN，此时客户端已经关闭，客户端会给服务器回一个RST，可能导致数据丢失情况。TIME_WAIT有助于可靠的实现TCP全双工的结束。

对于每一个TCP连接，操作系统会开辟一个接收缓冲区与发送缓冲区来处理数据。当正常close时，如果缓冲区有数据，会先将数据发送完毕再关闭，完成四次挥手。

RST【连接复位包】：出现这个标志，一般表示异常关闭。会直接关闭连接，导致缓冲区里的待发送数据丢失。

若服务器先关闭，会进入到TIME_WAIT状态，再次绑定器其地址，会报错，`bind: Address already in use`

**为什么TIME_WAIT等待的时间是2MSL？**

当主动断开的一方发送最后一个ACK报文后，进入到TIME_WAIT状态。2MSL时间可以确保ACK报文丢失情况下，客户端重新发送ACK报文。【当客户端发送的ACK报文丢失后，服务器在MSL时间内没有收到ACK，会重新发送FIN数据包，到客户端接收到这个FIN数据包，这个过程的最大时间是2MSL】

**TCP状态转换图**

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220423143926621.png" alt="image-20220423143926621" style="zoom: 67%;" />



#### 端口复用技术

解决上述问题，当主动方关闭时，其地址可以再次使用。

```c
//端口复用，通过setsockopt进行设置，关键代码如下
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
        //level：功能端口复用SOL_SOCKET
        //optname：SO_REUSEADDR、SO_REUSEPORT
int val = 1;
if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&val, sizeof(int)) < 0) 
    ERR_EXIT("setsockopt");
```

#### TCP滑动窗口

窗口理解为缓冲区的大小。

滑动窗口的大小会随着发送数据和接受数据而变化。

通信双方都有发送缓冲区和接受缓冲区 。

### I/O多路复用（I/O多路转接）

多路复用技术使得程序能够同时监听多个文件描述符，提高程序的性能。

委托内核

`select/poll`用户态与内核态不断切换，返回哪几个文件描述符可读可写，具体是哪个不清楚，需要遍历一次

`epoll`委托内核来监听，返回可读或可写的具体文件描述符。

#### select模型

缺点：

1. 每次调用select均需要将fd集合从用户态拷贝到内核态，当fd很多时，开销较大
2. 内核每一次都需要遍历所有传递进来的fd，当fd很多时，开销也较大
3. 支持的并发数量1024（fd_set集合容量为128）
4. fd集合不可以重用，每次都需要重置（maxfd一直更新，使用过的无法再用）

#### poll模型

poll改进：可连接数量没有限制，集合可重复利用

问题：每次调用用户态到内核态反复切换没有改进

#### epoll模型

源码 https://github.com/wangbojing

在内核创建一块实例（内存），返回一个文件描述符，可通过`epoll`的`API`来操作这段数据结构。

相当于创建一块共享内存，将感兴趣的事件放到里面，当有事件的数据发生变化时，将他们返回。

```c++
int epoll_create(int size);
//size > 0 任意数
//创建一个eventpoll实例在内核区，需要用close关闭
struct eventpoll {
    …
    struct rb_root rbr;  //待检测的文件描述符的信息（红黑树），rbr指向红黑树的根节点，节点中的key就是socket套接字
    ct list_head rdlist; //一个双向链表，rdlist指向链表头节点
    …
};

int epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);
//epollfd：通过调用epoll_create()创建的文件句柄
//op：进行的操作 EPOLL_CTL_ADD添加、DEL删除、MOD修改
	//ADD相当于向红黑树中添加节点、DEL删除节点、MOD修改节点信息
//fd：监听的socket套接字
//event：socket套接字的事件信息
//管理epoll实例，将一个socket以及socket相关的事件添加到实例中，epoll会监视他们，事件来时，会通知我们
struct epoll_event {
        uint32_t events;   /*oll events */
        epoll_data_t data;  /* User data variable */
};
//常见的epoll检测事件：	EPOLLIN, EPOLLOUT, EPOLLERR,  EPOLLET
typedef union epoll_data
{
	void *ptr;
	int fd;
	uint32_t u32;
	uint64_t u64;
} epoll_data_t;

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
//events：发生变化的文件描述符数组【有数据待读写的已连接的TCP个数】，大小为maxevents
//timeout：阻塞时间：0不阻塞；-1阻塞；>0阻塞时长
//返回值：>0：发生变化的文件描述符的个数；-1失败
//遍历双向链表，将双向链表中的节点拷贝到events数组中
	//同时将节点从链表中删除【但是这个节点并没有从内存中删除，依然存在于红黑树中】
	//每一次双向链表中的节点从何而来？内核将有事件发生的节点插入到双向链表中
		//哪些情况操作系统会将节点插入到链表中？
		//客户端完成三次握手，服务器要accept
		//客户端关闭连接，服务器要close
		//客户端发送数据过来，服务器要read，recv
		//有数据待发送，服务器要write，send
```

```c++
// 对应于一个加入到epoll的socket
struct epitem {
    // 挂载到eventpoll的红黑树节点
    struct rb_node rbn;
    // 挂载到eventpoll的双向链表节点
    struct list_head rdllink;
    // 连接到ovflist的指针
    struct epitem *next;
    /* 文件描述符信息fd + file, 红黑树的key */  
    struct epoll_filefd ffd;
    /* Number of active wait queue attached to poll operations */  
    int nwait;
    // 当前文件的等待队列(eppoll_entry)列表
    // 同一个文件上可能会监视多种事件, 这些事件可能属于不同的wait_queue中(取决于对应文件类型的实现),  所以需要使用链表
    struct list_head pwqlist;
    // 当前epitem的所有者
    struct eventpoll *ep;
    /* List header used to link this item to the &quot;struct file&quot; items list */  
    struct list_head fllink;
    /* epoll_ctl 传入的用户数据 */
    struct epoll_event event;
};
// epitem的高明之处在于，既能作为红黑树中的节点，又能作为双向链表中的节点
```



#### epoll的工作模式

EPOLLIN事件

内核中的socket接收缓冲区 为空     低电平

内核中的socket接收缓冲区 不位空 高电平

EPOLLOUT事件

内核中的socket发送缓冲区 满     低电平

内核中的socket发送缓冲区 不满 高电平

#### LT模式——水平触发

高电平触发

若有数据可读取，内核会一直通知，直到数据读取完毕

若有数据可写，将数据写入到内核缓冲区，若内核已满，将未发完的数据添加到应用层缓冲区，关注EPOLLOOUT事件。当EPOLLOUT事件到来，将应用层缓冲区数据发送，发送完毕，取消关注EPOLLOUT事件。

#### ET模式——边沿触发

高低电平转换触发

内核仅通知一次，如果数据没有读完或者没有读，下次内核也不会通知

必须设置非阻塞模式，循环读取，若没有读到说明读完

#### EAGAIN错误处理

非阻塞的系统调用，由于资源限制/不满足条件，导致返回值为EAGAIN

当调用read/write/recv等系统函数，如果缓冲区数据已满/为空，导致无法再向缓冲区提交/读取数据，产生了Resource temporarily unavailable的错误（资源暂时不可用），返回值就是EAGAIN，需要再次调用重新发送。

一般发生在epoll的ET模式

epoll的LT模式一般不会出现，因为LT模式有数据系统才会提醒你，所以不会出现换缓冲区为空的情况

#### EINTR错误处理

被中断，不做操作，重新发送/接收



#### telnet工具

命令行运行的客户端TCP通讯工具，可连接到服务器，发送数据，接收数据。

```shell
telnet IP port
```

#### wireshark工具

监控数据包

捕获 host 192.168.245.128 and port 80



