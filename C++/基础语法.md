# 基础语法

### 调试常见错误

1. rooting error（执行错误）：越界，比如数组字符串，对操作边界的代码检查一下

`runtime error: reference binding to null pointer of type 'int' (stl_vector.h)`的报错原因：vector在还没有分配任何空间时还不能像数组一样用下标形式去访问vector的（v[0]也不行）！！！否则编译通过但报运行错误runtime error！vector在还没有分配任何空间时还不能像[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)一样用下标形式去访问vector的（v[0]也不行）！！！否则编译通过但报运行错误runtime error！

vector二维数组初始化：

```c++
vector<vector<int>> vec (n, vector<int> (n, 0));
```

首先判断题目给定的数组是否为空，若不判断，为空时v[0]编译直接报错

```c++
if (matrix.size() == 0 || matrix[0].size() == 0)  return {};
```

一维数组：

```c++
vector<int> vec
```

一维数组临时变量并初始化

```cpp
vector<int> {1,2,2};
```

注意边界值1

双指针，right寻找不等于val的值，覆盖在原数组上，left指向新数组，返回值left为新数组的元素个数

2. 溢出错误

`Use after free`：访问堆上已经被释放的内存

`Heap buffer overflow`：堆上缓冲区访问溢出

`Stack buffer overflow`：栈上缓冲区访问溢出

`Global buffer overflow`：全局缓冲区访问溢出

`Use after return`：访问栈上已被释放的内存

`Use after scope`：栈对象使用超过定义范围

`Initialization order bugs`：初始化命令错误

`Memory leaks`：内存泄漏

`addition of unsigned offset ` 下标越界（出现-1）

`signed integer overflow` ：整型溢出

vector的size函数返回值是无符号类型。当size等于0的时候，对其减一，会造成越界溢出

```c++
//程序部分代码，当nums.size() < 3时，程序再往下判断只要用上nums[i],i > 0就会报错
for (int i = 0; i < nums.size() - 3; i++) {
            if (nums[i] > target) {
                return res;
            } else if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            cout << nums.size() - 3 << endl;
    		//……
    		for (int j = i + 1; j < nums.size() - 2; j++) {
                if (nums[i] + nums[j] > target) { //程序在这里报错
                    break;
            }
}
18446744073709551614
```



3. 访问是无效

```c++
Line 175: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type 'ListNode *', which requires 8 byte alignment (stl_deque.h)
0xbebebebebebec0b6: note: pointer points here
<memory cannot be printed>
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16
```

出这问题的根本原因是对队列或堆栈的访问是无效的（比如队列为空了，执行出队操作和取首元素操作）

```c++
while(s1.top()) {s1.pop();}
```

4. 力扣刷题不要设置全局变量或者类内静态变量

推荐做法：在类内（private）/函数内对全局变量或类内静态变量做初始化

5. 多个整数相加，将和转换为long型，避免int溢出
6. `abs() `取绝对值
7. `to_string` 将int 型转换成string类型
9. `find()`函数 查找元素，返回迭代器。找到返回元素指向的迭代器；找不到返回nums_set.end()。vector没有find函数，`set，map`有。

```c++
nums_set.find(num) != nums_set.end()； //判断容器中是否有n
```

10. 字符串操作函数

- `=, s.assign()` // 赋以新值 
- `stoi()` 将string类型字符串强制转换成Int型
- `swap() `// 交换两个字符串的内容 
- `s1.compare(s2)`比较大小
- `+=, s.append(), s.push_back()` // 在尾部添加字符 
- `pop_back()`尾删
- `s.insert(pos, "as") ` 在pos位置处插入字符串
- `s.erase(pos, n)` 删除从pos开始的n个字符
- `s.clear() `// 删除全部字符 
- `s.replace()` // 替换字符 
- `+` 串联字符串 
- `==,!=,<,<=,>,>=,compare() `// 比较字符串 
- `size(),length()` // 返回字符数量 
- `max_size() `// 返回字符的可能最大个数 
- `s.empty()` // 判断字符串是否为空 
- `s.capacity()` // 返回重新分配之前的字符容量 
- `reserve() `// 保留一定量内存以容纳一定数量的字符 
- `[ ], at()` // 存取单一字符 
- `>>`//将谋值写入stream 
- `<<` // 将谋值写入stream 
- `copy()` // 将某值赋值为一个C_string 
- `c_str() `// 返回一个指向正规C字符串(C_string)的指针 内容与本string串相同 有’\0’ 
- `data()` // 将内容以字符数组形式返回 无’\0’ 
- `s.substr(startindex, length)` 返回某个子字符串 
- `begin() end() `// 提供类似STL的迭代器支持 
- `rbegin() rend() `// 逆向迭代器 
- `get_allocator()` // 返回配置器
- `"2" - "0"` 将字符串转换为整数
- `int num = atoi(str.c_str())` 将str字符串转换成整数
- `int num = stoi(str)`将字符串转换成整数
- `str1 == str2`判断两个字符串是否相等
- `reverse(s.begin(), s.end())`反转字符串，无返回值

12. char 与int 转换 `char c = num + '0';int num = c - '0'`

### 双指针篇

数组：移除元素，快慢指针将待移除元素覆盖

字符串：反转字符串，前后双指针同时向中间移动，交换元素

​                替换空格，双指针从后向前遍历

链表：反转链表，双指针逐一反转，并记录后一指针的位置

​           链表中找环，快慢指针

N数之和：i从头遍历，循环内双指针分别从前后两个方向求和判断

#### 力扣203 移除链表元素

```cpp
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

pre用来记录待删除节点的上一个节点。

ret用来记录头节点。（找到第一个非val的节点）

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* pre = new ListNode(0, head);
        ListNode* newHead = nullptr;
        ListNode* pNode = head;
        bool ret = true;
        while (pNode) {
            if (pNode->val == val) {
                if (pNode->next) pre->next = pNode->next;
                else pre->next = nullptr;
                pNode = pre->next;
            }
            else {
                if (ret) {
                    newHead = pNode;
                    ret = false;
                }
                pre = pNode;
                pNode = pNode->next;
            }
        }
        return newHead;
    }
};
```

13. `ifndef`与`endif`，头文件中使用，防止头文件被多次调用。命名规则，文件名大写

14. `int main(int argc, char* argv[])`，`argc`是命令行总的参数个数，`argv[]`字符串数组，它的个数是`grgc`，`grgv[0]`是程序名字，后面跟用户输入的参数

15. ![image-20220502103840675](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220502103840675.png)

16. 子字符串是连续的；子序列可以不连续

17. 求整数的二进制  右移 然后 &1

    ```cpp
    vector<int> s1;
    for (int i = 31; i >= 0; i--) {
        s1.push_back(x >> i & 1);
    }
    for (int i = 0; i < 32; i++) {
        cout << s1[i];
    }
    x = 31
    00000000000000000000000000011111
    ```

18. istringstream类，执行C++风格的串流的输入操作，遍历时右移遇到空格停止

    ```c++
    string str = "i am a boy";  
    istringstream is(str);  
    string s;  
    while(is >> s)  
    {  
        cout << s << " ";
    }
    //cout
    //i am a boy的序列化与反序列化
    ```

    二叉树的序列化与反序列化

    ```c++
    class Codec {
    public:
        // Encodes a tree to a single string.
        string serialize(TreeNode * root) {
            if(root == nullptr){
                return "#";  // 子树为空时字符串插入"#"
            }
            return to_string(root->val) + ' ' + serialize(root->left) + ' ' + serialize(root->right);
        }
    
        TreeNode * mydeserialize(istringstream & ss){
            string tmp;
            ss >> tmp;  // 右移遇到空格停止
            if(tmp == "#"){
                return nullptr;  // tmp = "#" 子树为空 返回空
            }
            TreeNode * node = new TreeNode(stoi(tmp));
            node->left = mydeserialize(ss);
            node->right = mydeserialize(ss);
            return node;
        }
    
        // Decodes your encoded data to tree.
        TreeNode * deserialize(string data) {
            istringstream ss(data);
            return mydeserialize(ss);
        }
    };
    ```

19. vector（单口的数组）

    ```c++
    iterator erase(iterator first, iterator last) {/*清除范围元素*/}
    iterator erase(iterator position) {/*清楚指定元素*/}
    ```

    扩容机制：每次扩容capacity翻倍；

    缺点：配置新空间、转移元素、释放原来的空间，原来的迭代器都会失效。
    
    数据结构：线性空间
    
20. deque（双端数组）

    双端开口的连续的线性空间，内部是动态地分段连续的线性空间，整体连续。

    缺点：迭代器变得很复杂

    实现：采用一块map作为主控，每个元素都是指针，指向一块连续线性空间（缓存区），存储数据。

    扩容：配置一段定量的连续空间，在头部或尾部即可。

    

### 力扣超时问题

**2022/5/4**

**79**题，单词搜索题目。

递归传参时，值传递超时，引用传递不超时。

```cpp
    bool existFunc(vector<vector<char>>& board, string word, vector<vector<bool>>& ava,
                int index, int row, int cli, int m, int n) {
        if (index == word.size()) return true;
        if ((row < 0) || (cli < 0) || (row >= m) || (cli >= n)) return false;
        if (ava[row][cli]) return false;
        for (int i = row; i < m; i++) {
            for (int j = cli; j < n; j++) {
                if (word[index] == board[i][j]) {
                    ava[i][j] = true;
                    if (existFunc(board, word, ava, index + 1, i - 1, j, m, n) ||
                        existFunc(board, word, ava, index + 1, i + 1, j, m, n) ||
                        existFunc(board, word, ava, index + 1, i, j - 1, m, n) ||
                        existFunc(board, word, ava, index + 1, i, j + 1, m, n)) { 
                            return true;
                    }
                    else ava[i][j] = false;
                }
                if (index > 0) return false;
            }
        }
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        vector<vector<bool>> ava(m, vector<bool>(n, false));
        return existFunc(board, word, ava, 0, 0, 0, m, n);
    }
```

#### [18. 四数之和](https://leetcode.cn/problems/4sum/)

此题坑比较多，记录一下：

1. size()函数返回值是无符号类型，若小于0会变成特别大的数，导致后续报错
2. 此题数组的nums包括负数，判断时不能根据当前值大于目标值就跳过循环（目标值为负数的话，越加越小）
3. int整型溢出的问题，四个int相加能溢出，需要用long数据类型

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        if (nums.size() < 4) {
            return res;
        }
        for (int i = 0; i < nums.size() - 3; i++) {
            // if (nums[i] > target) { //存在负数相加 -5 -4 -3 等越加越小，不可跳过
            //     return res;
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            for (int j = i + 1; j < nums.size() - 2; j++) {
                // if (nums[i] + nums[j] > target) {
                //     break;
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                int left = j + 1, right = nums.size() - 1;
                while (left < right) {
                    if ((long)nums[left] + nums[right] == target - (long)(nums[i] + nums[j])) {
                        res.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == res.back()[2]) {
                            left++;
                        }
                        while (left < right && nums[right] == res.back()[3]) {
                            right--;
                        }
                    } else if ((long)nums[left] + nums[right] > target - (long)(nums[i] + nums[j])) {
                        right--;
                    } else {
                        left++;
                    }
                }
            }
        }
        return res;
    }
};
```

[(47条消息) 笔试时的ACM模式输入输出汇总（C++版）_风还好冷的博客-CSDN博客_acm模式](https://blog.csdn.net/qq_38436921/article/details/123928165)

[(47条消息) ACM题目中输入数据的处理（C++版）_迂者-贺利坚的博客-CSDN博客](https://blog.csdn.net/sxhelijian/article/details/8978850)