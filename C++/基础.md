# 类和对象

### 访问权限

public、protected、private：共有的、受保护的、私有的

1. 类内，定义类的代码内部，无论是哪个属性，都可以互相访问
2. 类外，只能通过对象来访问public成员
3. 继承
   1. 无论任何继承，<u>派生类内</u>仅可以访问共有成员和保护成员
   2. 共有继承，<u>类外对象</u>仅可以访问共有成员
   3. 保护继承和私有继承，类外对象无法访问基类的任何成员
4. 友元，作为类的好朋友，可以访问类的私有成员

### 静态成员变量和静态成员函数

静态成员变量和静态成员函数是属于类的，而不属于对象，在类实例化为对象之前，静态成员变量和静态成员函数就已经分配内存空间了

#### 静态成员变量

1. 类内声明，类外定义
2. 静态成员变量的生命期不依赖于任何对象，为程序的生命周期
3. 不属于任何对象，由类的所有对象共享
4. 可以通过类名、对象名访问公有成员变量

#### 静态成员函数

1. 属于整个类
2. 只能访问静态成员函数、静态成员变量
3. 可以通过类名、对象名访问公有成员函数

```c++
class test
{
private:
    static int m_value; //设置为私有，防止被外界任意修改
public:
    test() {
		m_value++;
    }
    static int getvalue() {
		return m_value;
    }
};
int test::m_value = 0;
int main()
{
    test t;
    cout << test::getvalue() << endl; //1
    cout << t.getvalue() << endl;     //1
}
```

### 虚函数（override）

**父类指针指向子类对象，调用普通重写函数时，会调用父类中的方法，调用被子类重写的虚函数时，会调用子类的方法**

```c++
class father
{
public:
    void A() {
        cout << "father A" << endl;
    }
    virtual void B() {
        cout << "father B" << endl;
    }
};

class son : public father
{
public:
    void A() {
        cout << "son A" << endl;
    }
    virtual void B() {
        cout << "son B" << endl;
    }
};

void test4() {
    father* m_father = new father;
    father* m_son = new son;
    son* m_s = new son;
    m_father->A();
    m_father->B();
    m_son->A();
    m_son->B();
    m_s->A();
    m_s->B();
}

int main() {
    test4();
    /*  father A
        father B
        father A
        son B
        son A
        son B
    */
}
```

多态：不同继承关系的类对象、调用同一函数实现不同的功能

当用指针调用虚函数的时候，即使是父类指针，也会调用子类的虚函数

#### 虚函数工作方式

依赖虚函数表：保存虚函数地址。当用基类指向派生类时，虚表指针指向派生类的虚函数表，保证虚函数被调用

#### 纯虚函数

实际上将一个类定义为抽象类，不能实例化对象

构造函数可以是纯虚函数

#### 特殊情况

incline、static、constructor三种函数不能带有virtual关键字

incline在编译时展开，必须有实体

static属于class自己的类，必须有实体

#### 多态实现

override重写：子类重写父类的虚函数

overload重载：同名函数，函数的参数类型不同（参数个数、参数类型、类型相同顺序不同）

#### 构造函数不可以是虚函数

构造函数中可以调用虚函数，只可以调用当前类中的虚函数，不可以调用子类的虚函数；

虚函数对应一个虚函数表，类中存放一个指针指向虚函数表。构造函数若是虚函数，就需要通过指针调用，但对象没有初始化前，没有指针指向虚函数表，就无法通过找到构造函数，因此构造函数无法定义成虚函数。

#### 析构函数最好是虚函数

基类指针可以指向派生类对象，如果删除基类指针，会调用派生类的析构函数，函数内再调用基类的析构函数，整个派生类全部删除。如如果析构函数不是虚函数，删除基类指针，仅会调用基类自己的析构函数，派生类的析构函数不会释放，造成内存泄漏。

#### 虚函数的重写

派生类中重写虚函数时，返回值类型、函数名字，参数列表必须完全相同。

两个特例：

- 协变（基类与派生类虚函数的返回值类型不同）：基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变。
- 析构函数的重写，如果基类将析构函数定义为虚函数，派生类的析构函数只要定义，无论是否加virtual，都构成重写。

### 内联函数incline

函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。

增加了内联函数：当编译器调用内敛函数时，不会将该语句翻译成函数调用指令，而是直接将函数体的代码插入到函数调用处，不需要额外的开销

### 模板特化与偏特化

模板有类模板、函数模板，

特化分为特化（全特化）和部分特化（偏特化）

对于函数模板：模板和特化版本应该声明在同一个头文件中，所有同名模板的声明放前面，接着是特化；特化模板必须有主模板，特化模板的类型必须全部明确化。

#### 函数模板

```c++
template<typename T, class N> 
void compare(T num1, N num2) {
    cout << "standard function template" << endl;
    if (num1 > num2) {
        cout << "num1:" << num1 << " > num2:" << num2 << endl;
    }
    else {
        cout << "num1:" << num1 << " <= num2:" << num2 << endl;
    }
}
```

##### 特化

```c++
/*特化*/
template<>
void compare<int, int>(int a, int b) {
    cout << "specialization" << endl;
    if (a >= b) {
        cout << "a: " << a << " >= b: " << b << endl;
    }
    else {
        cout << "a: " << a << " < b: " << b << endl;
    }
}
```

##### 偏特化

```c++
// 对部分模板参数进行特化
template<class N>
void compare(int num1, N num2) {
    cout << "partitial specialization" << endl;
    if (num1 > num2)
        cout << "num1:" << num1 << " > num2:" << num2 << endl;
    else
        cout << "num1:" << num1 << " <= num2:" << num2 << endl;
}

// 将模板参数特化为指针(模板参数的部分特性)
template<typename T, class N> 
void compare(T* num1, N* num2) {
    cout << "new partitial specialization" << endl;
    if (*num1 > *num2)
        cout << "num1:" << *num1 << " > num2:" << *num2 << endl;
    else
        cout << "num1:" << *num1 << " <= num2:" << *num2 << endl;
}
```

#### 类模板

```c++
template<typename T, class N> 
class TestClass {
public:
    static bool comp(T num1, N num2) {
        cout << "standard class template" << endl;
        return (num1 < num2) ? true : false;
    }
};
```

##### 特化

```c++
template<>
class TestClass<int*, char*> {
public:
    static bool comp(int* a, char* b) {
        cout << "specialization" << endl;
        return (*a < *b) ? true : false;
    }
};
```

##### 偏特化

```c++
// 对部分模板参数进行特化
template<class N> 
class TestClass<int, N> {
public:
    static bool comp(int num1, N num2) {
        cout << "partitial specialization" << endl;
        return (num1 < num2) ? true : false;
    }
};

// 将模板参数特化为指针
template<typename T, class N> 
class TestClass<T*, N*> {
public:
    static bool comp(T* num1, N* num2) {
        cout << "new partitial specialization" << endl;
        return (*num1 < *num2) ? true : false;
    }
};
```

#### 优先级

特化、偏特化、主模板

## struct和class的区别

- 默认权限不同，struct默认是public，class默认是private。
- 继承方式不同，struct默认是public，class默认是private。

### C++中struct相比C更新了什么？

- struct 中可以使用 public、private、protected等属性，和 C++ 一样。
- struct中可以添加方法（函数）
- struct可以继承等属性

## C语言数组表示地址

a[1]+3 = `&a[1][0]`+3  也就是`&a[1][3]` 表示二维数组`a[1][3]`的地址

类似于int a[3]

a+2 的时候a退化为a[0]的地址。

## 程序检查

### 1.

```c
void alloc_memory(char *var, const int size)
{
    var = malloc(size);
}
int main()
{
    char *s;
    alloc_memory(s, 10);
    strcpy(s, "abc");
    free(s);
    return 0;
}
```

s没有初始化，指向地址未知

alloc_memory函数应该传入二重指针，函数内部创建的内存没有释放，内存泄漏

strcpy时，因s没有初始化，产生段错误（segmentation fault）

