# C++11新标准

#### 代码的简洁性

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

来源：力扣（LeetCode）49题

如下是我写的代码：  暴力解法...

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        int array[strs.size()][26];
        memset(array, 0, sizeof(array));
        for (int i = 0; i < strs.size(); i++) {
            for (int j = 0; j < strs[i].size(); j++) 
                array[i][strs[i][j] - 'a']++;
        }
        vector<vector<string>> vec;
        int nums[strs.size()];
        memset(nums, 0, sizeof(nums));
        for (int i = 0; i < strs.size(); i++) {
            if (nums[i] == 0) {
                vector<string> v;
                v.push_back(strs[i]);
                nums[i] = 1;
                for (int j = i+1; j < strs.size(); j++) {
                    bool ret = true;
                    for (int k = 0; k < 26; k++) {
                        if (array[i][k] != array[j][k]) {
                            ret = false;
                            break;
                        }
                    }
                    if (ret && nums[j] == 0) {
                        v.push_back(strs[j]);
                        nums[j] = 1;
                    }
                }
                vec.push_back(v);
            }
        }
        return vec;
    }
};
```

如下是C++大佬根据C++11写的：

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> vec;
        map<string, vector<string>> m;
        for (auto s : strs) {
            string str = string(26, '0');
            for (auto c : s) {
                str[c - 'a']++;
            }
            m[str].emplace_back(s);
        }
        for (auto x : m) {
            vec.emplace_back(x.second);
        }
        return vec;
    }
};
```

惭愧啊

emplace()、emplace_back()

#### C++类成员函数指针

```c++
// 声明
typedef 返回值 (类名::*指针类型名)(参数列表);
// 赋值
指针类型名  指针名 = &类名::成员函数名;
// 调用
(类对象.*指针名)(参数列表);
(类指针->*指针名)(参数列表);
```

#### atomic原子操作

表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。

```c++
template<class T>
struct atomic
    
std::atomic<int> value;
value = 99;

std::atomic<int> value = 99;  //error，调用拷贝构造函数，c++11禁止编译器自动生成
```



#### constexpr常量表达式

值不会改变，并且在编译阶段就能得到计算结果的表达式，声明为constexpr的变量一定是一个const变量

在constexpr声明中如果定义了一个指针，限定符conxtexpr仅对指针有效，与指针所指的对象无关

```c++
static int i = 10;
std::cout << "i=" << i << std::endl;
constexpr int* p = &i;
*p = 8;
std::cout << "i=" << i << std::endl;
//输出：10  8
```

constexpr指针所指变量必须是全局变量或者static变量(既存储在静态数据区的变量)

#### 前置++与后置++

```c++
self &operator++() {
`	node = (linktype)((node).next);
	return *this;
}
const self operator++(int) {
	self tmp = *this;
	++*this;
	return tmp;
}
```

通过参数类型来区分

后置的返回值返回对象而不是引用，返回完毕临时对象就会被销毁

#### 强制类型转换

```c++
ThreadItem * pthread = static_cast<ThreadItem*>(p_thread);
```

- static_cast：没有运行时类型检查，无法保证转换安全性

上行转换（派生类转换为基类）：安全

下行转换（基类转换为派生类）：没有动态类型检查，不安全

使用：用于基类数据之间转换、把任意类型的转换为void类型

- dynamic_cast

运行时处理，运行时进行类型检查，其余三种全部是编译时完成的

下行转换时安全。转换类型仅支持类的指针、引用、void*

只能用于存在虚函数的父子之间的转换

- const_cast：常量指针/引用转换为非常量

- reinterpret_cast：鲁棒性极差，不推荐使用

## 1.类型推导

### auto

在编译阶段推导出变量的类型

在不声明为引用或指针时，auto忽略等号右边的引用和CV限定

### decltype

用于推导表达式的类型，编译器仅分析表达式的类型，不进行实际的计算表达式的值

保留表达式的引用和CV属性，对于`decltype(exp)`

- exp是表达式，`decltype(exp)`的类型与exp相同
- exp是函数调用，`decltype(exp)`的类型与exp函数返回值类型相同
- exp是左值，`decltype(exp)`是exp类型的左值引用

```c++
//普通类型
int func() {return 0};
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是不会实际调用func()

//const
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const

//引用与指针类型
//1.表达式引用
const int i = 3, &j = i;
decltype(j) k = 5;
cout << typeid(k).name() << endl; // int
cout << k << endl;  // 5
// k = 10; //报错，表达式必须是可修改的左值，k的类型是 const int&，这里区别于auto
decltype(auto) p = j;
cout << typeid(p).name() << endl; // int 实际 p 的类型是const int &
cout << p << endl;  // 3
//2.表达式引用，想要得到这个引用所指向的类型, 需要修改表达式
int i = 3, &r = i;
decltype(r + 0) t = 5; // 此时是int类型
//3.对指针的解引用操作返回的是引用类型
int i = 3, j = 6, *p = &i;
decltype(*p) c = j; // c是int&类型, c和j绑定在一起
//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用，加上一对括号，得到引用类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起
```

#### decltype(ayto)

C++14新增，声明变量时，必须初始化。推导变量时，先用初始化表达式替换auto，再根据decltype语法规则确定变量的类型。

```c++
#include<typeinfo>
int e = 4;
const int* f = &e;
decltype(auto) j = f;
cout << typeid(e).name() << endl;  // int
cout << typeid(f).name() << endl;  // int const *
cout << typeid(j).name() << endl;  // int const *
```

## 2.左值引用与右值引用

#### 左值

可以放在等号左边，也可以放在等号右边的变量，可以取地址并且有名字的变量。并不是所有左值都可以在等号左边，const修饰的变量，可以取地址，但不可以对其赋值。

总结：真正存在内存当中，而不是寄存器当中的值就是左值。

++i、--i是左值

#### 右值

仅能放在等号右边，不能取地址，没有名字。有常量值、函数返回值、lambda表达式等。无法获取地址，但不代表不可以改变，可以通过定义右值的右值引用来更改右值。

i++、i--是右值

#### 左值引用&

传统的C++引用，对象的别名

非常量左值仅接收非常量最值对其进行初始化；但常量左值引用是“万能”，接收非常量最值，常量左值，右值进行初始化。

#### 右值引用&&

C++11新增特性，对一个右值进行引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的储存位置。赋值时，等号右边必须是右值，可以使用std::move函数将左值强制转换成右值。

##### 特点

- 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样 长，只要该变量还活着，该右值临时量将会一直存活下去
- 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
- T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

```c++
template<typename T>
void fun(T&& t)
{
    cout << t << endl;
}
int getInt()
{
    return 5;
}
int main() {

    int a = 10;
    int& b = a;         //b是左值引用
    //int& c = 10;      //错误，c是左值不能使用右值初始化
    int && d = 10;      //正确，右值引用用右值初始化
    //int && e = a;     //错误，e是右值引用不能使用左值初始化
    const int& f = a;   //正确，左值常引用相当于是万能型，可以用左值初始化
    const int& g = 10;  //正确，左值常引用相当于是万能型，可以用右值初始化
    const int&& h = 10; //正确，右值常引用
    const int& aa = h;  //正确，左值常引用相当于是万能型，可以用右值初始化
    //int& i = getInt();//错误，i是左值引用不能使用临时变量（右值）初始化
    int&& j = getInt(); //正确，函数返回值是右值
    fun(10); //此时fun函数的参数t是右值
    fun(a);  //此时fun函数的参数t是左值
    return 0;
}
```

### 移动语义move semantic

避免无谓的复制，提高程序性能

[移动语义（move semantic）和完美转发（perfect forward）_donnyxia1128的博客-CSDN博客_移动语义](https://blog.csdn.net/summerhust/article/details/110677472?ops_request_misc=&request_id=&biz_id=102&utm_term=移动语义&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-110677472.142^v40^pc_rank_34_ecpm25,185^v2^control&spm=1018.2226.3001.4187)

#### 移动语义解决了什么问题

```c++
class Test {
    int* arr{ nullptr };
public:
    Test() :arr(new int[5000]{ 1,2,3,4 }) {
        cout << "default constructor" << endl;
    }
    Test(const Test& t) {
        cout << "copy constructor" << endl;
        if (arr == nullptr) arr = new int[5000];
        memcpy(arr, t.arr, 5000 * sizeof(int));
    }
    ~Test() {
        cout << "destructor" << endl;
        delete[] arr;
    }
};
Test createTest() {
    Test t;
    return t;
}
int main() {
    Test t = createTest();
}
```

运行结果

```c++
default constructor
copy constructor
destructor
destructor
```

RVO（Return  Value Optimization）是一种编译器优化机制：当函数需要返回一个对象的时候，如果自己创建一个临时对象返回，那么这个临时对象会消耗一个构造函数（Constructor）、一个拷贝构造函数（Copy Constructor）以及一个析构函数（Destructor）的调用的代价，RVO的目的就是消除为保存返回值而创建的临时对象，这样就可以将成本降低到一个构造函数的代价。

以上是优化后的结果，显示一次拷贝构造。实际上还有一次拷贝构造，createTest函数创建一个Test变量后，拷贝构造一个临时变量作为返回值。

每一次的拷贝构造都需要开辟空间，如果一个对象的成员变量占用大量内存的话，拷贝构造的开销非常大。

有没有一种办法再将createTest函数的返回值拷贝给t的时候，不需要重新开辟空间，拷贝复制，而是直接用临时对象的资源呢，这种偷走临时变量中的资源的方法叫做“移动语义”。

```c++
Test(Test&& t) : arr(t.arr) {
        cout << "move constructor" << endl;
        t.arr = nullptr;
}
```

```c++
default constructor
move constructor
destructor
destructor
```

由于函数返回值是一个临时变量，因此参数类型是右值引用。

通过移动构造函数，事实上我们是做了一个浅拷贝（shallow copy）.至于要将之前的指针置为空的原因在于，我们的类会在析构的时候delete掉我们的数组。那么我们浅拷贝出来的这个对象的成员变量（arr指针）就变成了一个悬挂指针（dangling pointer）。

## 3.NULL 与 nullptr

void表示“无类型”，void *表示无类型指针。在定义指针的时候，必须声明指针的类型，无类型指针可以接受任何类型的指针。

```c
double d = 3.14;
double *dptr = &d;
void * vptr = dptr;
```



C语言中：

```c
#define NULL   ((void *) 0)   //(void*)0是空字符
```

C语言支持隐式类型转换

C++支持函数重载，当C++程序中函数参数为NULL时：

```c
void func(int x) {
    cout<<"void func(int x)"<<endl;
}
 
void func(char *y) {
    cout<<"void func(int *y)"<<endl;
}
 
int main()
{
    func(NULL);
    return 0;
}
```

以上程序调用时，编译器不知道该执行哪个函数，NULL可以隐式转换到 int 或 char * ，具有二义性

```shell
[root@localhost ~]# g++ test.cpp -o test
test.cpp: 在函数‘int main()’中:
test.cpp:14:21: 错误：调用重载的‘func(NULL)’有歧义
            func(NULL);
                     ^
test.cpp:14:21: 附注：备选是：
test.cpp:4:7: 附注：void func(int)
  void func(int x) {
       ^
test.cpp:8:8: 附注：void func(char*)
   void func(char *y) {
```

因此C++11引入nullptr，解决二义性问题，nullptr用来表示空指针

```c++
int main()
{
    func(nullptr);
    return 0;
}
```

执行

```ell
[root@localhost ~]# g++ test.cpp -o test -std=c++11
[root@localhost ~]# ./test 
void func(int *y)
```

## 4.基于范围for循环

```c++
vector<int> arr(10, 400);
for (const auto & x : arr) {
    cout << "x" << endl;
    //……
}
```

## 5.lambda表达式

lambda表达式表示一个可调用的代码单元，没有命名的内敛函数，用来替换独立函数或函数对象

```c++
[capture] (parameters) mutable ->return-type {statement};
```

lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；

```c++
int main()
{
    vector<int> v{ 48,8,5,41581,14 };
    sort(v.begin(), v.end(), [](const int& a, const int& b) {return a > b; });
    for_each(v.begin(), v.end(), [](const int& a) {cout << a << " "; });
}
```

## 6.列表初始化

C++11可以直接在变量名后面加上初始化列表来进行对象的初始化操作

```c++
int a{1};  //头文件、源文件均可以

class student
{
public:
	string name{"bfiusbd"};  //可以在类里就地初始化, c++11 only
    int age{12};
};
student stu{"assff", 52};  //c++11 only，相当于 student stu("assff", 52);
student * ps = new student{"assff", 52}; //c++11 only，相当于 new student("assff", 52);

int * p = new int[]{1,2,32,45};   //c++11 only
```

当就地初始化与初始化列表同时存在时，先就地列表再初始化列表，最终以初始化列表为准

## 7.智能指针

[【C++】智能指针详解_Billy12138的博客-CSDN博客_智能指针](https://blog.csdn.net/flowing_wind/article/details/81301001?ops_request_misc=&request_id=&biz_id=102&utm_term=智能指针&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-81301001.142^v33^pc_rank_34,185^v2^control&spm=1018.2226.3001.4187)

C++ 动态内存管理通过new和delete完成，动态内存管理经常出现两个问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。

智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

**【模板类】**可以指定类型，传入指针通过构造函数初始化。也可以使用 make_shared函数初始化

### shared_ptr

允许多个指针指向同一个对象

```c++
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10,'9');
shared_ptr<int> p5 = make_shared<int>();
```

实现机制：<u>拷贝构造函数时使用同一份引用计数</u>

重载 `*,->,=`拷贝构造函数、析构函数

- 拷贝构造时引用次数加一；
- 赋值时减一，
- 当引用次数为0，delete
- 调用析构函数时，引用次数减一

### unique_ptr

“独占”所指向的对象

定义：绑定到一个new返回的指针上

不支持拷贝和赋值，可通过release、reset将所有权从一个unique_ptr转到另一个

有移动构造功能

```c++
p.release(); //p放弃对指针的控制权，返回指针，将p置空
p.reset();   //释放p指向的对象
//将所有权从p1（指向string Stegosaurus）转移给p2
unique_ptr<string> p2(new string("Stegosaurus"));
unique_ptr<string> p2(p1.release());
unique_ptr<string> p3(new string("Trex"));
//将所有权从p3转移到p2
p2.reset(p3.release());  //reset释放了p2原来指向的内存，同时p3置空，所有权转移到p2
p2 = nullptr;  //释放p2所指向的对象，将p2置空
```

### auto_ptr

不安全的指针，已经被c++11弃用

- 为了解决“有异常抛出时发生内存泄漏”的问题，抛出异常，将导致指针p所指 向的空间得不到释放而导致内存泄漏；
- 构造时创建对象，析构函数释放对象；
- 构造函数是explicit，阻止一般指针隐式转换为auto_ptr的构造，必须使用构造函数创建对象；
- 析构时释放对象，不安全的原因，多个对象管理同一个指针；
- 析构函数内部：删除对象调用delete，不是delete[]，不能管理数组；
- 支持所拥有的指针类型之间的隐式类型转换；
- 可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；
- T* get()，获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。

### 实现智能指针

1) 智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录Smart_Pointer对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。 除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。 通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用 计数加1；

2) 一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；