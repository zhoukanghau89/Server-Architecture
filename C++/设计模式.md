# 设计模式

## 三层架构

一种用在特定客户机-服务器的体系结构模式，是逻辑三层系统

体系结构分为三成：数据层、应用层、表示层

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220717100058236.png" alt="image-20220717100058236" style="zoom: 50%;" />

1. 表示层：

顶层，将内容发送到网络开发框架中的浏览器，并以图形界面的形式（GUI）显示信息，允许用户直接访问。通过调用API将结果输出到浏览器和其他层

2. 应用层：

业务逻辑层、中间层，通过处理应用程序的业务逻辑，在表示层和数据层间建立一个桥梁，使表示层和数据层之间通信

3. 数据层：

由持久存储机制和数据层组成，支持数据库连接，根据输入执行增删改查等等操作

规则：

1. 表示层只是一个外壳，不能包含任何应用程序与数据库之间操作的处理。
2. 核心是应用层，应用层的编程接口应该以面向对象的方式在用用编程接口上实现所有的操作。
3. 数据层必须要独立于抽象系统层。
4. 多个服务器要考虑负载均衡

优点：

1. 减少层与层之间的依赖性，需要遵循接口标准，使用对象模型的相同实体类，允许不同的开发人员在每一层工作，显著提高开发速度
2. 每一层都可以重新开发，不会影响三层架构中的其他层，缩短了开发时间，降低了将新功能集成到软件服务器的成本
3. 易于维护，不会影响其他模块
4. 表示层不直接访问数据层，只与业务逻辑层连接，保证数据安全性



## 面向对象设计原则

面向对象设计原则为支持可维护性、可复用性而诞生，这些原则蕴含在很多设计模式中，是从许多设计方案中总结出的指导性原则

**高内聚、低耦合**

单一职责原则：类的职责单一，对外只提供一种功能

开闭原则：类的改动是通过增加代码改进的，而不是修改代码

依赖倒转原则：依赖于抽象接口，不要依赖于具体实现的类，针对接口编程

迪米特法则：降低各个对象的耦合，提高系统的可维护性，知道最少原则。把需要对外暴漏的接口设置成public，不需要对外暴漏的设置成private。如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用

合成复用原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合

## 1.工厂模式

### 简单工厂模式

客户端不需要考虑类的实现，直接拿来使用，传入参数，让工厂知道创建什么类型的对象

**定义一个类负责创建其他类的实例，根据实际的参数不同返回不同的实例**

缺点：不够灵活……增加新的功能是通过修改源代码实现，不符合开闭原则；工厂任务过重，一旦不能工作，系统收到影响

读文本 — 解析文本 — 创建A对象 — 给set属性值

```c++
#include <bits/stdc++.h>
using namespace std;

//抽象水果
class AbstractFruit {
public:
	virtual void ShowName() = 0;
};

//苹果
class Apple :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是苹果!" << endl;
	}
};

//香蕉
class Banana :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是香蕉!" << endl;
	}
};

//鸭梨
class Pear :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是鸭梨!" << endl;
	}
};

//水果工厂
class FruitFactor {
public:
	static AbstractFruit * CreateFruit(string flag) {
		if (flag == "apple") {
			return new Apple;
		}
		else if (flag == "banana") {
			return new Banana;
		}
		else if (flag == "pear") {
			return new Pear;
		}
		else {
			return NULL;
		}
	}
};

void test01() {
	FruitFactor* factory = new FruitFactor;
	AbstractFruit* fruit = factory->CreateFruit("apple");
	fruit->ShowName();
	delete fruit;

	fruit = factory->CreateFruit("banana");
	fruit->ShowName();
	delete fruit;

	fruit = factory->CreateFruit("pear");
	fruit->ShowName();
	delete fruit;

	fruit = NULL;
	delete factory;
	factory = NULL;
}

int main(){
	test01();
	return 0;
}
```

### 工厂方法模式

简单工厂模式 + 开闭原则 = 工厂方法模式

**定义一个抽象接口，负责给出不同工厂实现的方法，自身不再负责创建产品，将具体的创建操作交给实现该接口的子工厂类来完成**

```c++
#include <bits/stdc++.h>
using namespace std;

//抽象水果
class AbstractFruit {
public:
	virtual void ShowName() = 0;
};

//苹果
class Apple :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是苹果!" << endl;
	}
};

//香蕉
class Banana :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是香蕉!" << endl;
	}
};

//鸭梨
class Pear :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是鸭梨!" << endl;
	}
};

//抽象工厂
class AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() = 0;
};


//苹果工厂
class AppleFactory :public AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() {
		return new Apple;
	}
};

//香蕉工厂
class BananaFactory :public AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() {
		return new Banana;
	}
};

//鸭梨工厂
class PearFactory :public AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() {
		return new Pear;
	}
};


void test01() {
	AbstractFruitFactory* factory = NULL;
	AbstractFruit* fruit = NULL;

	//创建一个苹果工厂
	factory = new AppleFactory;
	fruit = factory->CreateFruit();
	fruit->ShowName();
	delete fruit;
	delete factory;

	//创建一个香蕉工厂
	factory = new BananaFactory;
	fruit = factory->CreateFruit();
	fruit->ShowName();
	delete fruit;
	delete factory;

	//创建一个鸭梨工厂
	factory = new PearFactory;
	fruit = factory->CreateFruit();
	fruit->ShowName();
	delete fruit;
	delete factory;
	fruit = NULL;
	factory = NULL;

}

int main() {
	test01();
	return 0;
}
```



### 抽象工厂模式

产品族：同一产地或者同一厂商，功能不同的物品

产品等级：功能相同的同类物品，产地或厂商不同

**进一步抽象，将相关产品构成一个产品族，由同一个工厂生产吗，增加新的产品族很方便；但增加新的产品等级结构麻烦，需要大量修改代码，违背开闭原则**

使用场景：

1. 系统中有多个产品族，每次只使用一个，可以通过配置文件等方式让客户可以动态改变产品族，也很可以很方便地增加新的产品族；
2. 产品结构稳定，设计完成后，不需要向系统添加新的产品等级结构

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220715163306806.png" alt="image-20220715163306806" style="zoom: 67%;" />

## 2.单例模式

类的对象只能有一个，系统只允许创建一个，不允许修改，并提供一个全局访问接口

实现步骤：

1. 构造函数私有化
2. 定义静态私有的当前类的指针变量
3. 提供静态的全局接口，创建实例化对象，返回单例对象

#### 懒汉式（线程不安全）

用了再创建

```c++
class Singleton {
private:
    Singleton() {}
    static Singleton * m_instance;
public:
    static Singleton * GetInstance() {
		if (m_instance == NULL) {
            m_instance = new Singleton();
        }
        return m_instance;
    }
};
Singleton * Singleton::m_instance = NULL;
```

#### 饿汉式

提前创建好，用的时候直接返回

```c++
class Singleton {
private:
    Singleton() {
		cout << "饿汉单例模式创建好了" << endl;      
    }
    static Singleton * m_instance;
public:
    static Singleton * GetInstance() {
        return m_instance;
    }
};
Singleton * Singleton::m_instance = new Singleton();
int main() {
	cout << "main程序开始执行……" << endl;
}

饿汉单例模式创建好了
main程序开始执行……
```

#### 加锁懒汉式

双重检查 + 锁 保证线程安全

```c++
class Singleton {
private:
    Singleton() {}
    static Singleton * m_instance;
    locker m_locker;
public:
    static Singleton * GetInstance() {
        if (m_instance == NULL) {
            m_locker.lock();
            if (m_instance == NULL) {
            	m_instance = new Singleton();
        	}
            m_locker.unlock();
        	return m_instance;
        }
    }
};
Singleton * Singleton::m_instance = NULL;
```

#### 局部变量懒汉式

C++11以后,使用局部变量懒汉不用加锁

```c++
class Singleton {
private:
    Singleton() {}
public:
    static Singleton * GetInstance() {
        static Singleton m_instance;
        return & m_instance;
    }
};
```

## 3.代理模式

为其他对象提供一种代理以控制对这个对象的访问。某些时候一个对象不方便直接引用另一个对象，代理对象可以在客户端和服务器之间起到中介的作用

常用情况：远程代理、虚代理、保护代理、智能引用

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220716110037525.png" alt="image-20220716110037525" style="zoom:67%;" />

Subject类：抽象类，提供一个共用接口，方便RealSubject和Proxy类调用

RealSubject类：实体类，定义一个真实的实体

Proxy类：代理类，保存一个引用可以访问实体类，用来替代实体，共客户访问

实例：在文档中嵌入图形对象的文档编辑器。有些图形的开销很大，打开文档的要求是要快。所以避免打开文档时一次性创建所有开销很多的对象，运用代理模式。打开文档时，打开代理以替代真实的图形，等到需要真正打开图形时，仍由代理打开。

代理类保证我们不需要实际访问实体类

```c++
//抽象类
class Image
{
public:
	Image(string name): m_imageName(name) {}
	virtual ~Image() {}
	virtual void Show() {}
protected:
	string m_imageName;
};
//实体类
class BigImage: public Image
{
public:
	BigImage(string name):Image(name) {}
	~BigImage() {}
	void Show() { cout<<"Show big image : "<<m_imageName<<endl; }
};
//代理类
class BigImageProxy: public Image
{
private:
	BigImage *m_bigImage;
public:
	BigImageProxy(string name):Image(name),m_bigImage(0) {}
	~BigImageProxy() { delete m_bigImage; }
	void Show() 
	{
		if(m_bigImage == NULL)
			m_bigImage = new BigImage(m_imageName);
		m_bigImage->Show();
	}
};
void test5() {
    Image* m_image = new BigImageProxy("aaa.jpg");
    m_image->Show();
    delete m_image;
    //Show big image : aaa.jpg
}
```

## 4.适配器模式

将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

接口已经写好，但是不匹配，用适配器转换成匹配的接口

```c++
//已经写好的接口
struct Myprint
{
    void operator()(int v1, int v2) {
        cout << v1 + v2 << " ";
    }
};
//接口抽象类
class Target
{
public:
    virtual void operator()(int v) = 0;
};
//适配器类
class Adapater : public Target
{
public:
    Adapater(int num) : num(num){}
    virtual void operator()(int v) {
        m_Myprint(v, num);
    }
public:
    int num;
    Myprint m_Myprint;
};
Adapater setnum(int v) {
    return Adapater(v);
}

void test6() {
    vector<int> v;
    for (int i = 0; i < 5; i++) {
        v.push_back(i);
    }
    for_each(v.begin(), v.end(), setnum(10));
    //10 11 12 13 14
}
```

## 5.策略模式

将各种算法单独封装，提供相同的对外接口

构成：

1. Stragety抽象接口类
2. ConcreteStragetyA，ConcreteStragetB，具体的策略类实现
3. Context提供操作策略的类：构造函数包含Stragety类，通过多态传进来不同的具体策略

优点：使用策略模式可以避免使用多重条件转移语句，提高维护效率

缺点：客户端需要知道所有的策略类

## 6.命令模式

将一个逻辑请求封装成一个任务对象，客户提交不同的请求，将**请求排队或者记录请求日志**，支持可撤销的操作

```c++
#include <iostream>
#include <queue>
#include <Windows.h>
using namespace std;

//协议处理类
class HandleClientProtocol {
public:
	//处理增加金币
	void AddMoney() {
		cout << "给玩家增加金币！" << endl;
	}
	//处理增加钻石
	void AddDiamod() {
		cout << "给玩家增加钻石！" << endl;
	}
	//处理玩家装备
	void AddEquipment() {
		cout << "给玩家穿装备！" << endl;
	}
	//处理玩家升级
	void AddLevel() {
		cout << "给玩家升级！" << endl;
	}
};

//命令接口
class AbstractCommand {
public:
	virtual void handle() = 0; //处理客户端请求的接口
};

//处理增加金币请求
class AddMoneyCommand :public AbstractCommand {
public:
	AddMoneyCommand(HandleClientProtocol* protocol) {
		this->pProtocol = protocol;
	}
	virtual void handle() {
		this->pProtocol->AddMoney();
	}
public:
	HandleClientProtocol* pProtocol;
};

//处理增加钻石的请求
class AddDimondCommnd :public AbstractCommand{
public:
	AddDimondCommnd(HandleClientProtocol* protocol) {
		this->pProtocol = protocol;
	}
	virtual void handle() {
		this->pProtocol->AddDiamod();
	}
public:
	HandleClientProtocol* pProtocol;
};

//处理玩家装备装备的请求
class AddEquipmentCommnd :public AbstractCommand {
public:
	AddEquipmentCommnd(HandleClientProtocol* protocol) {
		this->pProtocol = protocol;
	}
	virtual void handle() {
		this->pProtocol->AddEquipment();
	}
public:
	HandleClientProtocol* pProtocol;
};

//服务器程序
class Server {
public:
	void addRequest(AbstractCommand* command) {
		mCommands.push(command);
	}
	
	void startHandle() {
		while (!mCommands.empty()) {

			Sleep(2000);

			AbstractCommand* command = mCommands.front();
			command->handle();
			mCommands.pop();
		}
	}
public:
	queue<AbstractCommand*> mCommands;
};

void test01() {

	HandleClientProtocol* protocol = new HandleClientProtocol;
	//客户端增加金币的请求
	AbstractCommand* addmoney = new AddMoneyCommand(protocol);
	//客户端增加钻石的请求
	AbstractCommand* adddimond = new AddDimondCommnd(protocol);
	//客户端穿装备的请求
	AbstractCommand* addequiment = new AddEquipmentCommnd(protocol);

	//将客户端请求加入到处理的队列中
	Server* server = new Server;
	server->addRequest(addmoney);
	server->addRequest(adddimond);
	server->addRequest(addequiment);
	//服务器开始处理请求
	server->startHandle();
}
int main() {

	test01();
	return 0;
}
```

## 7.观察者模式

观察者模式是定义对象间的一种一对多的依赖关系，每一个对象发生状态改变时，相关依赖对象皆得到通知并自动更新。又叫发布-订阅模式、模型-视图模式、源-监听器模式或者从属者模式

优点：

1. 观察者模式实现表示层与数据逻辑层分离，观察者模式在观察目标与观察者之间建立一个抽象的耦合，支持表示层作为各类型的观察者角色
2. 支持广播通信
3. 符合开闭原则

缺点：

1. 观察目标需要通知到所有观察者，如果观察者较多的情况下，不适合
2. 如果观察者和观察目标之间存在循环依赖的话，会导致系统崩溃
3. 不支持观察者了解观察目标如何发生变化，只支持了解发生了什么变化

### 8.装饰器模式

动态地给一个对象添加一些额外的功能

为每个装饰的功能提供一个单独的类，需要时候让这个类包装它所要装饰的对象

客户可以根据需要，有选择地、按照顺序地使用装饰功能包装对象

优点：可以很方便地拓展，装饰类与装饰对象独立开发，不会相互耦合，可以动态添加一个类的实现功能

关键点：装饰对象使用装饰类





































































































