# C++内存

所需内存空间分为固定部分与可变部分。

1. 固定部分
   - 代码区 存储二进制代码
   - 数据区 全局变量、静态变量、常量
2. 可变部分
   - 栈区 先进后出 形参、返回值、递归栈需要的空间系统自动分配和回收
   - 堆区 先进先出 动态开辟的空间，存放new的对象在堆区的数据，需要手动回收
3.  如何计算程序占用多大内存

64位的操作系统，指针占8个字节，64个比特，可以寻址2^64的内存空间

##  内存对齐

为什么会有内存对齐？

1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
2. 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。

CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。

假设CPU把内存划分为4字节大小的块，要读取一个4字节大小的int型数据，来看一下这两种情况下CPU的工作量：

第一种就是内存对齐的情况，如图：

<img src="https://img-blog.csdnimg.cn/20200804193307347.png" alt="内存对齐" style="zoom:67%;" />

第二种是没有内存对齐的情况如图：

<img src="https://img-blog.csdnimg.cn/20200804193353926.png" alt="非内存对齐" style="zoom: 67%;" />

char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：

1. 因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据

2. CPU读取4，5，6，7处的四个字节数据

3. 合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据

此时一共需要两次寻址，一次合并的操作。

## 内存泄漏

由于疏忽或错误导致程序未能释放掉不再使用的内存的情况，并非指在物理上的消失，实际上是某段程序分配后，失去了对该内存的控制，导致内存的浪费

内存泄漏检查：Valgrind，mtrace

### 分类

#### 堆内存泄漏Heap Leak

堆内存：malloc、realloc、new等从堆中分配的一块内存，使用后必须通过free、delete删掉，若未被释放，这段程序将会不再被使用

#### 系统资源泄漏Resource Leak

程序使用系统分配的资源Bitmap、handle、socket等响应函数后未释放，导致系统资源浪费，严重可导致系统效能降低，运行不稳定

#### 基类的析构函数没有设定成虚函数

当基类指针指向子类对象时，如果基类的析构函数不是虚函数，那么子类对象的虚函数将不会被调用，子类的资源没有正确释放，造成内存泄漏

### 原因以及解决办法

指针指向改变，未释放掉动态分配的内存。

解决：将内存的分配封装在一个类中，构造函数分配内存，析构函数释放内存；尽量使用智能指针

智能指针：为了解决动态内存分配导致的内存泄漏和多次释放同一内存。<memory>头文件中，包括共享指针、独占指针、弱指针

析构函数要设为虚函数：不设为虚函数，当需要释放子类的资源时，只会调用基类的析构函数，派生类资源无法释放

### 野指针

指向未知的内存地址

野指针不会以引发错误，操作野指针指向的内存会引发错误

#### 成因

- 指针未初始化
- 指针越界访问
- 指针释放后未置空。free或delete后未赋值NULL，仅将内存释放掉，但指针本身还存在且指向无效内存

``` cpp
int * p = new int[10];
delete [] p;
if (p != NULL) {
	p[0] = 1;  //报错，操作无效内存
}
```

正确做法是释放内存后

```c++
P = NULL；
```

## 内存分配

#### new和malloc

- new是操作符，malloc是函数
- new在分配时先分配内存，再调用构造函数，释放的时候调用析构函数
- operate new/operate delete 可以被重载
- malloc需要指定申请内存的大小
- new比malloc更安全
- new失败抛出bac_alloc异常，malloc返回NULL
- new从自由存储区上为对象动态分配内存空间，malloc函数从堆上动态分配内存

#### C++内存分配方式

（1）静态（全局）存储区分配

内存在程序编译的时候就已经分配好，这块内存在整个程序运行期间一直存在，全局变量，静态变量等

（2）代码区

存放程序二进制代码，包括类成员函数和非成员函数

（3）在栈上创建

在执行函数时，函数的返回地址、形参、局部变量在栈上自动创建存放，函数执行结束时，存储单元被自动释放

（4）在堆上分配

程序运行时候使用malloc和new申请内存，使用free和delete释放，生存期由程序员自由决定，灵活

#### 自由存储区和堆

C++标准没有给出new/delete实现方式，很多编译器的new/delete都是以malloc/free为基础来实现的。从技术上来说，堆（heap）是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，使用malloc、free来申请/释放内存。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。基本上，所有的C++编译器默认使用堆来实现自由存储。也就是说，<u>默认的全局运算符new和delete也许会使用malloc和free的方式申请和释放存储空间，自由存储区就位于堆上。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就不位于堆上了。</u>

## sizeof

32位机器下测试（X86）

### 1.类

#### 1.空类

```c++
class A {};
int main()
{
    cout << sizeof(A) << endl;  //1
    A a;
    cout << sizeof(a) << endl;  //1
}
```

空类的大小是1，空类可以被实例化，每个实例对象有一个自己的地址。空类最为基类后，大小为0.

#### 2.静态成员

```c++
class A {
    static int a;
};
int main()
{
    cout << sizeof(A) << endl;  //1
    A a;
    cout << sizeof(a) << endl;  //1
}
```

静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小，因此内存依然是1.

#### 3.虚函数

```c++
class A {
    virtual void func() {};
};
int main()
{
    cout << sizeof(A) << endl;  //4
    A a;
    cout << sizeof(a) << endl;  //4
}
```

虚函数类对象中有一个指向虚函数表的指针，指针大小为4

#### 4.普通函数

```c++
class A {
    void func() { cout << "A" << endl; };
    int a;
};
int main()
{
    cout << sizeof(A) << endl;  //4
    A a;
    cout << sizeof(a) << endl;  //4
}
```

普通函数同样不占用类的大小

```c++
class A {
    void func() { cout << "A" << endl; };
    int a;
    virtual void Func() {};
    static int b;
};
int main()
{
    cout << sizeof(A) << endl;  //8
    A a;
    cout << sizeof(a) << endl;  //8
}
```

int类型占4个，虚函数指针占4个。







