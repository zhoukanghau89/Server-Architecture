# TCP/IP协议

## 应用层

#### HTTP请求和响应报文有哪些手段？

请求报文

![](https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png)

- 请求行：请求方法、URL、协议版本
- 请求头
- 请求体

响应报文

- 状态行
- 响应头
- 响应体

#### 请求方法主要是？区别

- Get是获取数据，Post是修改数据

- get把请求的数据放在url上， 以？分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在数据包包体内

- get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制

- GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 k(返回数据)。

- GET请求会被浏览器主动缓存，而POST不会

- 本质区别：GET是幂等的，而POST不是幂等的（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果）。因此不能用Get来对数据进程增删改（会有对数据进行重复操作的风险）。

  比如发送一个hello word，Get放在URL上，Post放在请求体

## 传输层

#### 粘包问题

发送端可能将多个小包合并成一个包发送，也可能将一个大包拆分成几个包发送；接收端可能在接收过程中，又来了几个包都到了缓冲区，最后可能一个接收了多个包。如何解决？

包头 + 包体格式

数据包包头定长 包头存放整个数据包的长度

先收包头，根据包头中的数据包的长度计算出包体的长度，再收包体

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220628170826352.png" alt="image-20220628170826352" style="zoom:50%;" />

#### TCP三次握手

SYN：握手信号；ACK：确认信号；Ack/ack：应答信号；seq：随机序号

三次握手根据TCP头部进行交互；

TCP三次握手发生在客户端连接时，客户端调用`connect`时；

思想：“让我知道你已经知道”。交互双方都需要确保自己能接收发送数据。

![](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220421151027979.png)

```c
初始状态：客户端处于关闭状态，服务器端处于监听状态，客户端执行connect时，触发三次握手
第一次握手：
1.客户端将SYN标志位置为1
2.生成一个32位的随机序号seq=J ， 这个序号后边是可以携带数据（数据的大小）
第二次握手：
1.服务器端接收客户端的连接： ACK=1
2.服务器会回发一个应答号： ack=客户端的序号 + 数据长度 + SYN/FIN(按一个字节算)
3.服务器端会向客户端发起连接请求： SYN=1
4.服务器会生成一个随机序号：seq = K
第三次握手：
1.客户单应答服务器的连接请求：ACK=1
2.客户端回复收到了服务器端的数据：ack=服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)
双方建立TCP连接后，均为ESTABLISHED（已连接状态）
```

监听套接字队列：未完成连接队列，已完成连接队列

若当前已完成连接队列的排队数达到backlog，此时再有客户发送SYN请求，服务器将会忽略这个请求，不予回应。

因此若保证服务器尽可能多地处理客户请求，应尽快用accept把已完成队列中的连接取走

**三次握手详谈**

服务器调用listen监听端口等待客户端发起连接，当客户端调用connect向服务器发送一个数据包，并阻塞在这里等待服务器的应答包。服务器收到客户端发来的数据包后，将客户端的第一次握手放在监听套接字的未完成连接队列中，此时这个连接状态从LISTEN状态变成SYN_RCVD状态，服务器向客户端回应一个应答包，服务器调用accept并阻塞在这里等待客户端的应答包。客户端收到应答包后，连接状态从SYN_SENT状态变成ESTABLISHED状态，此时connect函数返回，向服务器发送一个应答包建立第三次连接。服务器收到客户端的应答包后，连接状态从SYN_RCVD变成ESTABLISHED状态，此时服务器将当前TCP连接加入到已完成连接队列中。accept函数将已完成队列的头部取出来返回给进程，并返回一个新的套接字。

**区分两个套接字**

监听套接字，只用来监听服务器的80端口，监听是否有客户端向服务器发起连接

已连接套接字，也叫通信套接字，用来保持客户端与服务器之间的通信，数据收发功能

**为什么需要三次握手？**

1. 确认双方的接收能力与发送能力均正常，并同步双方的序列号与确认号

2. 避免伪造数据包对服务器的攻击

服务器必须收到ack回应包才确信客户端是真实存在的，否则当前连接会一直放在未完成队列中，这个过程一般持续75ms，如果客户端一直不发送第三次握手连接，服务器会将当前连接从未完成队列中清除掉。

3. syn攻击
4. 避免浪费资源。若两次握手，服务器无法判断客户端是否接收到自己的确认信号，因此每收到一个连接请求就主动建立连接，造成资源浪费；当消息滞留时，服务器重复收到无用的连接请求，造成重复分配资源。

**三次握手可以携带数据吗？**

只有第三次可以。前两次防止恶意攻击，发送大量无用数据，造成对方花费时间，内存空间来接收这些报文。

**SYN攻击**

服务器的资源分配是在第二次握手时分配的，客户端是在第三次握手时分配。当客户端在短时间内伪造大量不存在的IP地址时，并向服务器不断地发送SYN包。服务器则回复确认包，并等待客户端确认，由于源地址不存在，因此服务器需要不断地发送直至超时，这些伪造的数据包占用未连接队列，导致正常的SYN请求因队列满了而被丢弃，从而导致网络拥塞甚至系统瘫痪。

如何预防？

- 缩短超时时间【SYN Timeout】
- 增加未连接队列数
- 过滤网关防护
- SYN cookies技术

#### TCP 四次挥手

FIN：finish结束包；RST：连接复位包

发生在断开连接时，谁先调用`close`谁发起四次挥手请求。

![image-20220421151132892](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220421151132892.png)

释放过程：客户端发起关闭连接的请求，服务器可能数据没有传送完毕，收到客户端请求后首先发送一个ack告诉客户端我收到你的请求了，但我还有工作要做，等服务器数据传输完毕给客户端发送FIN信号，此时服务器等待客户端的回信。让服务器知道客户端已经知道了，因此客户端收到后再次给服务器端发送一个回信，服务器收到后完成关闭连接。为了防止回信丢失，客户端再等2MSL个时间再关闭

**MSL**，maximum srgment lifetime，报文最大生存时间，任何报文被丢弃前在网络上的最长时间。

**主动断开**的一方，会进入到**TIME_WAIT**状态，应尽量避免服务器出现此状态，一般持续一分钟左右，这个时间内，这个端口是不允许被使用的。

**为什么要引入TIME_WAIT状态？**

假设主动断开的一方为客户端。若客户端最后发送的Ack应答包丢失，那么服务器端会重新发送FIN，这样因为客户端有TIME_WAIT的存在，会重新向服务器端发送Ack应答包。但是如果没有TIME_WAIT这个给状态，客户端发送完Ack应答包后就会关闭，若Ack丢失，服务器会重新发送一个FIN，此时客户端已经关闭，客户端会给服务器回一个RST，可能导致数据丢失情况。TIME_WAIT有助于可靠的实现TCP全双工的结束。

对于每一个TCP连接，操作系统会开辟一个接收缓冲区与发送缓冲区来处理数据。当正常close时，如果缓冲区有数据，会先将数据发送完毕再关闭，完成四次挥手。

RST【连接复位包】：出现这个标志，一般表示异常关闭。会直接关闭连接，导致缓冲区里的待发送数据丢失。

若服务器先关闭，会进入到TIME_WAIT状态，再次绑定其地址，会报错，`bind: Address already in use`

**为什么TIME_WAIT等待的时间是2MSL？**

当主动断开的一方发送最后一个ack报文后，进入到TIME_WAIT状态。2MSL时间可以确保ack报文丢失情况下，客户端重新发送ack报文【当客户端发送的ack报文丢失后，服务器在MSL时间内没有收到ack，会重新发送FIN数据包，到客户端接收到这个FIN数据包，这个过程的最大时间是2MSL】

关闭连接的方式不止有FIN报文段，还有RST报文段。如果进程异常退出，内核就会发送RST报文来关闭，不需要走四次挥手流程，暴力关闭。安全关闭连接的方式只有四次挥手。

**四次挥手谁调用的，如何调用？**

由进程调用close、shutdown函数发起的FIN报文。

有什么区别？

close函数完全断开，调用close的一方叫做孤儿连接。

shutdown可以控制一个方向的连接。

```c
int shutdown(int sock, int howto);
```

关闭读：若接收缓冲区有数据，则丢弃。收到新的数据后也不做处理，给丢弃掉。

关闭写：若发送缓冲区还有数据，将其发送出去，并发送一个FIN报文给对等端

关闭读写



#### TCP协议如何保证可靠传输？

**TCP连接由内核维护，内核会为每个连接建立内存缓冲区【读写缓冲区】，当内核收到报文时，用缓冲区接收他们，内核缓冲区可用空间变小；当进程调用read/recv，数据就被读入到用户空间，内核缓冲区可用空间变大**

- 确认+重传：接收方收到报文后就会确认，发送方发送一段时间后（MSL）没有收到确认就会重传


- 数据检验：TCP报文头部有检验和，用于检验报文是否损坏
- 数据合理分片与排序：根据最大传输单元MTU合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层处理
- 流量控制：滑动窗口保证数据传输可靠性，当接收方来不及处理数据时，TCP头部会告诉发送方窗口大小
- 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失

（流量控制是接收方决定，拥塞控制是发送方决定）

TCP分片：MSS【Maximum Segment Size，最大报文长度】，待发送数据大于MSS（TCP报文总长-TCP头部长度 > MSS），进行分片，在接收端重组，若某分片丢失，重传该分片即可。

**滑动窗口**

TCP通过滑动窗口实现流量控制，控制发送方发送速率【让发送方根据接收方的实际接收能力来控制发送数据的量】。滑动窗口的大小就是接收方还有多少缓冲区可以用于接收数据，发送方可以根据滑动窗口的大小来确定应该发送多少字节的数据。

窗口的大小通常由接收方的窗口大小来决定，并且是动态的。内核根据TCP连接的缓冲区大小来确定窗口的大小。

**拥塞控制**

拥塞窗口，指发送方在RTT【往返时延】时间内可以最多发送的数据包数。

通过拥塞窗口（`congestion window，cwnd`）来防止过多的数据注入网络。

一般只要发送方没有在规定时间内收到ack应答报文，就发生超时重传，认为网阔出现拥塞

#### 网络优化

**如何确定最大传输速度？**

TCP的传输速度受限于发送窗口、接收窗口以及网络设备传输能力。

窗口大小由内核缓冲区决定，如果缓冲区与网络传输能力匹配，那么缓冲区的利用率达到最大化。

**如何计算网络传输能力？**

带宽，网络传输速率 b/s，B/s，每秒的传输的速度

1Mb/s = 1024 * 1024b/s = 1024 * 128B/s =  128KB/s

带宽延迟乘机BDP = 传播时延 * 带宽，决定网络中飞行报文的大小/某段链路现在有多少比特，飞行【在网络线路、路由器等网络设备上】

网络时延RTT

发送缓冲区的大小决定了发送窗口的上限，发送窗口决定飞行报文的上限

因此，发送缓冲区 <= 带宽时延积

发送缓冲区 < 带宽时延积：无法发挥网络的传输效率

发送缓冲区 > 带宽时延积：超出的那部分无法有效的传输，导致网络超载，容易丢包

#### 拥塞控制的算法

何为拥塞，什么情况下会产生拥塞？

发送方投放到网络中的数据超出了网络的承载能力，发送方发送的数据没有被接收时都在网络中的缓冲区里，当缓冲区的数据已经积满在往里面发送时，就会被丢弃掉。

网络中缓冲区的吞吐量小于单位时间发送的数据量

**慢启动 slow start**

TCP刚建立时，一点一点地提速，试探一下网络的承载能力，避免扰乱网络秩序

1. 初始时将拥塞窗口cwnd设为1
2. 每当收到一个ACK，cwnd大小加1，线性上升
3. 每当过了一个往返的延迟时间RTT（Round-Trip Time），cwnd大小乘2，指数上升
4. 当cwnd达到ssthresh（slow start threshold，慢启动阈值，一般为65535个字节），进入拥塞控制避免算法

**拥塞控制避免算法 Congestion Avoidance**

达到ssthresh，拥塞控制避免算法可以避免cwnd增长过快导致窗口拥塞，开始缓慢的调整网络的最佳值

1. 每当收到ACK，cwnd += 1/cwnd，开始线性增长
2. 每当过了一个往返的延迟时间RTT，cwnd加1

**拥塞发生时的算法**

- 超时重传

在规定时间内没有收到ACK应答报文，需要重传

TCP重新传送数据包 ssthresh = cwnd/2，cwnd = 1，进入慢启动过程

丢包就重来，不利于网络数据的稳定传输，次方案抛弃

- 快速重传

发送端接收到三个以上的重置ACK，TCP意识到数据丢失，需要重传

ssthresh = cwnd = cwnd/2，进入快速恢复算法

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220629200748028.png" alt="image-20220629200748028" style="zoom: 67%;" />

**快速恢复算法 Fast Recovery**

cwnd += 3，重传数据包，如果再收到重置的ACK，cwnd加1

当发送成功，接收到新的ACK后，cwnd = ssthresh，恢复算法结束，回到拥塞避免算法

#### TCP、UDP区别

1. 连接方面：TCP面向连接的，传输前需要三次握手建立连接；UDP不需要连接，即刻传输
2. 服务形式：TCP只能1对1，点对点；UDP支持一对多
3. 可靠性：TCP保证数据可靠性，确认应答、重传机制、无重复、不丢失等；UDP不保证可靠性
4. 连接控制：TCP有流量控制、拥塞控制；UDP在网络拥堵情况下不会降低发送速率
5. 首部大小：TCP首部最短是20字节，后面4N字节根据需要增加；UDP固定8字节
6. 传输方式：TCP基于字节流；UDP基于数据包
7. 分片方式：TCP数据在传输层分片传输，到了后在传输层进行合并，若有数据丢失重传丢失的分片；UDP在网络层分片以及合并，若丢失重传整个数据包

#### TCP协议运行时阶段

TCP协议的运行可划分为三个阶段：

连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）

## 网络层

IP层位于TCP/IP模型的第三层，网络层。网络层的功能：实现主机与主机之间的通信，点对点通信。

IPv6技术：隧道技术、地址翻译技术（NAT）、双栈技术

### IP地址基础

IPv4地址形式 点分十进制 192.168.1.1

IP地址由两部分组成：网络ID、主机ID

#### IP地址分类：

| 类   | 最高位 | 地址范围                  | 网络IP字节数 | 用途      | 子网掩码      |
| ---- | ------ | ------------------------- | ------------ | --------- | ------------- |
| A    | 0      | 0.0.0.0~127.255.255.255   | 1            | 单播/特殊 | 255.0.0.0     |
| B    | 10     | 128.0.0.0~191.255.255.255 | 2            | 单播/特殊 | 255.255.0.0   |
| C    | 110    | 192.0.0.0~223.255.255.255 | 3            | 单播/特殊 | 255.255.255.0 |
| D    | 1110   | 224.0.0.0~239.255.255.255 | /            | 组播      | /             |
| E    | 1111   | 240.0.0.0~255.255.255.255 | /            | 保留      | /             |

0.0.0.0表示宿主机

110 00000 00000000 00000000 00000000 192.0.0.0.0

分类号110 网络号 

主机号为全0 表示指定某个网络

主机号为全1 指定网络下的所有主机用于广播，表示在同一个链路中相互连接的主机之间发送数据包

#### CTDR无分类地址

10.100.122.2/24，前24位是网络号，后8位是主机号

可用地址个数254个，子网掩码255.255.255.0，网络号10.100.122.0

地址范围10.100.122.1~10.100.122.254，广播地址10.100.122.255

网络号与主机号必须分离，方便判断是否处于同一个广播地址内【网络地址是否相同】，若网路地址相同，表面接收分在本网络内，可直接将数据发送到目标主机。路由器在寻址过程中，也是这个思路。

子网划分

将主机地址划分为两个部分：子网网咯地址、子网主机地址

如192.168.1.0，使用子网掩码255.255.255.192进行子网划分，具体：

将主机号的前两位作为子网网络号 ==》对应四个子网

得到网络地址：192.168.1.0，192.168.1.64，192.168.1.128，192.168.1.192

#### IP地址与路由控制

IP地址的网络地址用于路由控制。路由控制表中记录网络地址、下一步要发送的路由器地址。主机和路由器上有各自的路由器控制表

具体操作：发送IP包时，首先确定IP头部的目的IP地址，从路由表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给下一个路由器，如果路由控制表中存在多条相同网络地址的记录，选择最长匹配的记录。

![image-20220701141401735](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701141401735.png)

#### IP分片

数据链路层的最大传输单元MTU，以太网的MTU是1500字节

当IP数据包大小 > MTU，进行IP分片，在目标主机进行重组。

分片丢失的话，整个IP数据包进行重传。

#### IP头部

![image-20220630113004442](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630113004442.png)

固定长度是20字节

### DNS基础

#### DNS【Domain Name System】域名系统

域名与IP相互映射的一个分布式数据库

域名解析：通过主机名，得到该主机名对应的IP地址的过程

工作原理：将主机名转换为IP地址，属于应用层协议，使用UDP传输。原因：使用UDP协议，UDP快，UDP的DNS协议只要一个请求，一个应答。

域名层级关系：www.baidu.com 句点表示不同层级之间的界限，靠右层级高

域：cn、com等

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630113624816.png" alt="image-20220630113624816" style="zoom: 67%;" />

#### DNS域名解析流程

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630113809627.png" alt="image-20220630113809627" style="zoom: 80%;" />

#### 浏览器地址栏输入URL，按下回车经历以下几个流程

1.浏览器向DNS服务器请求解析该URL中的域名锁对应的IP地址

浏览器缓存 ==》本地DNS服务器 ==》DNS根服务器 ==》域服务器 ==》域名解析服务器

本地服务器将域名与IP地址对应关系保存在缓存中

2.根据IP地址和默认端口80，和服务器建立TCP连接

3.浏览器发出读文件的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器

4.服务器对浏览器请求做出响应，将对应的HTML文本发送给浏览器

5.释放TCP连接

6.浏览器将该HTML文本显示内容

#### ARP与RARP协议

ARP【Address Resolution Protocol，地址解析协议】

传输IP数据报的时候，确定源IP地址与目的IP地址后，通过主机路由表确定IP数据包下一跳。

网络层的下一层是数据链路层，需要知道下一跳的MAC地址。

通过ARP协议，求下一跳MAC地址。

在ARP高速缓存上查询是否有目的IP对应的MAC地址，没有的话，在局域网内发送ARP请求广播，局域网内的所有主机都会收到ARP请求，只有为下一跳IP地址的主机会将自己的MAC地址发送过来。

操作系统会将这个映射关系保存起来，方便下次使用。

RARP【Reverse Address Resolution Protocol，反向地址解析协议】，根据MAC地址解析得到IP地址。

#### DHCP

DHCP【Dynamic Host Configuration Protocol，动态主机配置协议】

客户端没有IP地址，使用UDP广播通信。源IP地址 0.0.0.0（端口号是68），目的IP地址 2552.255.255.255（端口号是67），DHCP客户端的链路层将数据帧广播到局域网，DHCP收到报文后，回应DHCP报文，报文中携带客户端可临时使用的IP地址、子网掩码、默认网关、DNS服务器。客户端收到后，从DHCP报文中选择一个向其发送请求报文，服务器用DHCP ACK回应客户端，可以使用配置参数。

UDP广播后，可能不止一个服务器回应，因此客户端需要从中选择一个。

#### NAT

NAT【Network Address Translation，网络地址转换】

Linux NAT模式【共享主机的IP地址】

![img](https://www.linuxidc.com/upload/2016_09/160926204664451.png)

主机网卡与虚拟NAT设备相连，虚拟NAT设备与虚拟DHCP服务器连接，然后将虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机上，实现虚拟机联网

虚拟网卡：实现虚拟机与主机之间的通信

没有虚拟网卡，虚拟机上网不受影响，但无法与主机之间通信，比如远程通信Xshell无法连接

#### ICMP协议

ICMP【Internet Control Message Protocol，互联网控制报文协议】

当IP数据包发送失败的时候，返回一个ICMP数据包，报告发送方遇到了什么问题，失败原因。

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630164318633.png" alt="image-20220630164318633" style="zoom:50%;" />

ICMP大致分为两类：

查询报文类型：用于诊断

差错报文类型：通知出错原因

#### IGMP协议

IGMP【Internet Group Management Protocol，因特网组管理协议】

D类地址，组播地址，只有在一组的主机能收到数据包

如何管理是否在一组？

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630165028703.png" alt="image-20220630165028703" style="zoom:67%;" />

IGMP协议工作在主机和与主机直接相连的路由器之间

主机必须加入到组播组，路由器才会转发组播包到主机

IGMP工作机制：

1. 常规查询与响应机制：路由器周期性地发送IGMP常规查询报文，目的地址224.0.0.1（表示同一网段内的所有主机和路由器）；主机收到这个查询后，启动一个随机定时器报告，定时器到时间后，会发送IGMP成员报告（源IP为主机IP，目的IP为组播地址）；若在定时器超时之前，收到同一组内的其他主机发送的报告，则自己不重复发送
2. 离开组播组工作机制：某主机发送IGMP离开报文（目的地址224.0.0.2，向网段内的所有路由器），路由收到后发送IGMP查询报文，若还有其他主机在组内，主机会响应报文让路由器知道该网段内还有组播成员；若网段内没有组内成员，没有主机响应查询报文，之后路由器不会再转发组播地址的数据包

## 网络综合

**问题：输入网址到网页显示，期间发生了什么？**

### SEP1

#### 1. 解析URL，生成发送给web服务器的HTTP请求信息

URL【Uniform Resource Locator，统一资源定位器】

```html
http://192.168.110.129:10000/root/webserver/resources/index.html
```

http:协议

192.168.110.129:10000 服务器的名字【主机名/域名】

/root/webserver/resources/index.html 数据源文件的路径名【可省略，后表示访问根目录下的的默认文件】

#### 2.生成HTTP请求信息

对URL地址解析后，浏览器获得了web服务器和文件名，根据这些信息生成HTTP请求报文

### SEP2

**通过浏览器解析URL并生成HTTP报文后，查询服务器的名字对应的IP地址，然后委托操作系统将消息发送给web服务器**

- 查询域名对应的IP地址 ==》DNS域名解析

- 万事具备，只欠东风 ==》发送数据包

#### 可靠传输-TCP

##### TCP包头格式：

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630214324507.png" alt="image-20220630214324507" style="zoom: 80%;" />

源端口号、目的端口号必不可少

包的序号：解决包乱序的问题

确认号：确认发出去是否收到

状态位：SYN发起一个连接；ack应答；RST重新连接；FIN结束连接。TCP面向连接，这些状态位会影响双方状态

窗口大小：流量控制，拥塞控制

##### 首先建立三次握手

##### 查看TCP连接状态

```shell
netstat -napt
```

##### TCP分割数据

请求消息过长大于MSS，TCP拆分数据

![image-20220630215338804](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630215338804.png)

数据被以MSS长度为单位进行拆分，拆分后的数据被放进单独的网络包，每个数据加上TCP头部信息，然后交给IP

##### TCP报文生成

双方建立连接后，TCP报文中的数据部分存放 HTTP头部 + 数据，组装好TCP报文后，交给网络层处理

![image-20220630220247825](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630220247825.png)

#### 数据包-IP

IP模块将TCP报文封装成网络包发送给通信对象

##### IP包头格式：

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701091239185.png" alt="image-20220701091239185" style="zoom: 80%;" />

##### 查询Linux系统路由表

```shell
[zhou@localhost ~]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.245.1   0.0.0.0         UG    100    0        0 ens33
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
192.168.245.0   0.0.0.0         255.255.255.0   U     100    0        0 ens33
```

发往任何IP的数据包都由默认网关192.168.245.1通过ens33网卡转发，0.0.0.0表示匹配任意IP地址

##### IP报文生成

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701093148905.png" alt="image-20220701093148905" style="zoom: 80%;" />

#### 两点传输-MAC

##### 以太网头部

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701093512461.png" alt="image-20220701093512461" style="zoom: 80%;" />

发送方的地址在网卡的ROM里

接收方在路由表中查询，MAC只负责两点传输，即下一跳的MAC地址

MAC头部的功能：将数据包送到路由器，其中的接收方MAC地址就是路由器地址（下一跳的地址）。

包头协议两种：

- 0800：IP协议
- 0806：ARP协议

通过ARP协议，求下一跳MAC地址，然后载入ARP缓存

查询ARP缓存：

```shell
[zhou@localhost ~]$ arp -a
? (192.168.245.11) at 00:50:56:c0:00:08 [ether] on ens33
gateway (192.168.245.1) at 00:50:56:e3:0f:9f [ether] on ens33
```

##### MAC报文

MAC头部：IP头部：TCP头部：HTTP报文：数据

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220630215338804.png" alt="image-20220630215338804" style="zoom: 80%;" />

#### 出口-网卡

网络包在内存中就是一段二进制数字。没有办法直接发送给对方。需要将数字信息转化为电信号（磁生电），才能在网线上传输，这才是真正的数据发送过程。执行这一操作的是网卡，控制网卡执行的是网卡驱动程序

具体操作：网卡驱动从IP层获取到包后，将其复制到网卡内的缓存区，在包头加上 报头和起始帧分界符，末尾加上用于检测错误的帧校验序列。

![image-20220701101254521](C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701101254521.png)

#### 送别者-交换机

到这为止，一个数据包已经被发出来了

首先，交换机将电信号转换为数字信号，通过包尾的FCS校验错误，没问题将包放入缓冲区。交换机基于以太网设计的，端口不具有MAC地址，将收到的包直接放到缓冲区中。

交换机中有一个MAC地址表，里面记录MAC地址连接在交换机的哪个端口

若没有记录，交换机会将包转发到所有端口，等收到返回的相应包后，交换机会记录在MAC地址表中

如果MAC地址是一个广播地址，交换机也会将包转发到所有端口

广播地址：

- MAC：FF:FF:FF:FF:FF:FF
- IP：255.255.255.255

#### 出境大门-路由器

数据包经交换机后到达路由器，在此被转发到下一个路由器或者目标设备

路由器是基于IP设计的，端口具有MAC地址、IP地址

首先路由器会接收发给自己的以太网包，然后通过包尾的FCS校验错误，没有问题查询MAC头部的接收方MAC地址是否和自己匹配，匹配就放到接收缓冲区，否则丢弃；

接下来去掉MAC头部，路由器根据IP头部的内容进行转发操作。首先查询路由表，判断路由表的网关

- 若网关是一个IP地址，则这个IP地址就是我们要转发的目标地址，需要继续转发
- 若网关是空，已经抵达目标IP

若需要继续发送，循环上面MAC处的操作。首先ARP地址解析协议（利用网关IP）找到下一跳的MAC地址；然后生成MAC报文（填写MAC发送方与接收方的MAC地址字段，发送方MAC是输出端口的MAC地址，协议类型为0800）；接下来将数字信号转换成电信号并通过端口发送出去。

发送后的网络包会达到下一个路由器，重复这个过程直到目的地……

整个传输过程中源IP、目的IP是不变的，只有MAC地址一直变化，需要MAC地址在以太网内进行两个设备之间的传输。

#### 交换机转发

到这里，说明数据包已经抵达了目的地，一路上有可靠传输的TCP、远程定位功能的IP、指明下一站的MAC等等。

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701145556512.png" alt="image-20220701145556512" style="zoom:67%;" />

# 操作系统、计网大综合——Linux收发网络包

### 网络模型

- 应用层：负责向用户提供一组应用程序，HTTP、DNS
- 传输层：负责端到端的通信，TCP、UDP
- 网络层：负责网络包的封装、分片、路由、转发，IP、ICMP、IGMP
- 链路层：负责网络包在物理链路中的传输，网络包的封帧、MAC寻址、差错检测、网卡传输

### 数据封装

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701150303651.png" alt="image-20220701150303651" style="zoom: 67%;" />

### Linux网络协议栈（重点）

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701150427141.png" alt="image-20220701150427141" style="zoom:67%;" />

socket通信接口【应用程序与操作系统协议栈之间的一座桥梁】，操作系统提供给用户的一个接口，用户调用这个接口实现网络通信，具体实现由操作系统来做，用户在使用过程中通过调用socket接口（就是一些系统调用）来使用TCP/IP提供的服务。

**通信能力的提供者是操作系统，操作系统提供所有的协议服务，这种服务通过SOCKET暴漏给用户**

| 应用程序   | 网络应用程序（浏览器、web服务器）           | 应用程序通过socket库，委托协议栈工作           |
| ---------- | ------------------------------------------- | ---------------------------------------------- |
| socket API | socket/listen/bind/connect/accept等系统调用 | 上下的桥梁                                     |
| 操作系统   | 协议栈，TCP/UDP，ICMP/ARP/IP，MAC           | 传输层、网络层、数据链路层                     |
| 驱动程序   | 网卡驱动程序                                | 负责控制网卡                                   |
| 硬件       | 物理硬件网卡                                | 负责实际的收发操作，对网线中的信号执行收发操作 |

由上到下，上级调用下一级，下级收到委托的工作并执行

## 操作系统内部如何实现发送和接收数据包？

操作系统：创建socket时，操作系统会创建一个由文件系统管理的socket对象（套接字），这个对象包含**<u>发送缓冲区、接收缓冲区、等待队列</u>**等成员。

![img](https://pic1.zhimg.com/80/v2-1c7a96c8da16f123388e46f88772e6d8_hd.jpg)

#### 工作队列

进程的状态：阻塞态、运行态等

工作队列中包含操作系统创建的所有进程及他们的状态。

#### 等待队列

将等待中的进程的引用添加到队列中，以便在接收到数据时获取进程对象、将其唤醒。

#### 进程阻塞

系统调用：recv、select、epoll等

进程在等待某事件发生之前的状态，比如系统调用。

#### 唤醒进程

当阻塞进程收到待获取的事件后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续允许。。。

#### 进程调度

在进程间切换CPU，最大化CPU利用率，通过操作系统的调度使得计算机资源分配和使用更加高效。

### 阻塞进程为什么不占用CPU资源？

假设工作队列中A、B、C三个进程

当进程A执行某个系统调用导致进程A阻塞后，操作系统会将进程A从工作队列移动到该socket的等待队列中，工作队列中还剩B和C，依据进程调度，CPU会轮流执行这两个程序，不会执行进程A的程序，所以进程A被阻塞，不会占用CPU的资源。

## 发送

1. 应用程序调用socket API发送数据包【系统调用】，从用户态切到内核态，将数据包拷贝到socket发送缓冲区
2. 网络协议栈从内核缓冲区取出数据包，按照TCP协议栈从上到下逐层封装打包
3. 触发软中断通知网卡驱动程序有新的数据包待发送
4. 驱动程序通过DMA技术从发送队列中取出网络包，放入到硬件网卡的队列中，随后物理网卡将其发送出去

## 接收

Linux内核在2.6版本中引入NAPI机制【New API】，混合中断和轮询的方式接收网络包，核心：不采用中断方式读取数据，采用中断唤醒数据接收的服务程序，用轮询的方式来轮询数据

进程在阻塞期间……

1. 网络包达到时，通过DMA技术，网卡将网络包放入Ring Buffer【环形缓冲区】
2. 网卡发起硬件中断，执行网卡中断处理函数，中断处理函数会唤醒软中断来轮询处理数据
3. 软中断从Ring Buffer中拷贝数据到内核struct_sk_buff缓冲区，将网络包交给网络协议栈处理
4. 链路层首先检测报文合法性，不合法直接丢弃；接着找出网络的上层协议IPv4、IPv6，去掉帧头与帧尾；网络层取出IP包判断包的下一步的走向，是交给上层处理还是转发
5. 若是交给本机的，去掉IP头，交给传输层判断协议TCP、UDP，找出对应的socket，并将数据拷贝到socket的接收缓冲区。
6. 唤醒阻塞的进程，将进程重新放入到工作队列中。
7. 最后应用层调用socket API，从内核获取数据到应用层处理……

#### 操作系统如何知道网络数据对应于哪个socket？

根据四元组【源IP、目的IP、源端口、目的端口】，找出对应的socket，并将数据拷贝到socket的接收缓冲区。为了提高速度，操作系统会维护端口号到socket的索引结构，以快速读取。

<img src="C:/Users/zhouk/AppData/Roaming/Typora/typora-user-images/image-20220701165835474.png" alt="image-20220701165835474"  />

## 同时监视多个socket

[(5条消息) Epoll的本质（内部实现原理）_Lailikes的博客-CSDN博客_epoll实现原理](https://blog.csdn.net/songchuwang1868/article/details/89877739?ops_request_misc=%7B%22request%5Fid%22%3A%22166166195016782246449555%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=166166195016782246449555&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-89877739-null-null.142^v42^pc_rank_34_2,185^v2^control&utm_term=epoll原理&spm=1018.2226.3001.4187)

服务器需要管理多个socket，从select到epoll的演进……

### select

假如能够预先传入一个socket列表，如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程，这就是select的思想。

调用select后，操作系统将进程A加入到所有监控socket的等待队列中；

当任何一个socket收到数据后，中断程序被唤醒；

唤醒进程，即将进程A从所有等待队列中移除，加入到工作队列中；

程序并不知道，哪些socket有数据，遍历一次。

缺点：

1. 每次调用select都需要将进程加入到所有监控的socket等待队列，每次唤醒将进程从所有等待队列移除
2. 应用层的程序不知道哪个socket有数据，需要重新遍历。

### epoll

有没有减少遍历和拷贝开销的方法？这两个问题便是epoll技术要解决的。

#### 功能分离

将等待队列和阻塞进程分离。

epoll_ctl维护等待队列，epoll_wait阻塞进程。

![img](https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_hd.jpg)

#### 就绪列表

epoll维护一个就绪列表，引用收到数据的socket，避免遍历。当进程被唤醒，只需要获取rdlist的内容，就能知道哪些socket收到数据。

### 实现原理

#### 创建epoll对象

调用epoll_create方法，内核会创建一个eventpoll对象，eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列（有线程会等待其事件触发，比如调用epoll_wait的线程就会阻塞在其上）。

#### 维护监视列表

创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。

#### 接收数据

当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。

#### 阻塞和唤醒进程

调用epoll_wait函数，内核会将进程A放入eventpoll的等待队列中，阻塞进程。

当某个socket有数据可读时，中断程序操作eventpoll对象给rdlist添加socket引用（中断程序并非直接操作进程）。

如果rdlist不为空，1. epoll_wait直接返回socket的个数，2. 唤醒eventpoll等待队列中的进程，进程A再次进入运行状态，3. 否则阻塞进程。

#### eventpoll数据结构

```c
struct eventpoll {
    /* Protect the access to this structure */
    spinlock_t lock;

    /*
     * This mutex is used to ensure that files are not removed
     * while epoll is using them. This is held during the event
     * collection loop, the file cleanup path, the epoll file exit
     * code and the ctl operations.
     */
    struct mutex mtx;

    /* Wait queue used by sys_epoll_wait() */
    //这个队列里存放的是执行epoll_wait从而等待的进程队列
    wait_queue_head_t wq;

    /* Wait queue used by file->poll() */
    //这个队列里存放的是该eventloop作为poll对象的一个实例，加入到等待的队列
    //这是因为eventpoll本身也是一个file, 所以也会有poll操作
    wait_queue_head_t poll_wait;

    /* List of ready file descriptors */
    //这里存放的是事件就绪的fd列表，链表的每个元素是下面的epitem
    struct list_head rdllist;

    /* RB tree root used to store monitored fd structs */
    //这是用来快速查找fd的红黑树
    struct rb_root_cached rbr;

    /*
     * This is a single linked list that chains all the "struct epitem" that
     * happened while transferring ready events to userspace w/out
     * holding ->lock.
     */
    struct epitem *ovflist;

    /* wakeup_source used when ep_scan_ready_list is running */
    struct wakeup_source *ws;

    /* The user that created the eventpoll descriptor */
    struct user_struct *user;

    //这是eventloop对应的匿名文件，充分体现了Linux下一切皆文件的思想
    struct file *file;

    /* used to optimize loop detection check */
    int visited;
    struct list_head visited_list_link;

#ifdef CONFIG_NET_RX_BUSY_POLL
    /* used to track busy poll napi_id */
    unsigned int napi_id;
#endif
};
```

这个 epitem 结构是干什么用的呢？

每当我们调用 epoll_ctl 增加一个 fd 时，内核就会为我们创建出一个 epitem 实例，并且把这个实例作为红黑树的一个子节点，增加到 eventpoll 结构体中的红黑树中，对应的字段是 rbr。这之后，查找每一个 fd 上是否有事件发生都是通过红黑树上的 epitem 来操作。

#### 索引结构

epoll将维护队列和进程阻塞分离，需要有个数据结构来维护监听的socket，需要方便添加和删除。

红黑树是一种自平衡二叉树，搜索、插入和删除的时间复杂度都是O(logN)。

当有事件发生时，rdlist引用epitem；

同时，红黑树中的节点也是epitem。

































